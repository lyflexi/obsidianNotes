死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。死锁的四个必要条件如下：

1. 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
    
2. 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
    
3. 不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
    
4. 循环等待条件：指在发生死锁时，必然存在一个进程—资源的环形链，即进程集合`{P0，P1，P2，···，Pn}`中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。若干个进程间形成了首尾相接循环等待资源的情况
    

# 如何预防死锁

1. 破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的(临界资源需要互斥访问)
    
2. 破坏请求与保持条件：一次性申请所有的资源。
    
3. 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
    
4. 破坏循环等待条件：靠按序申请资源来预防。进程在申请资源时必须按照序号递增的顺序进行资源的申请，释放资源则反序释放。
    

# 死锁避免算法

银行家算法是一种死锁避免算法，该算法允许进程动态申请资源。系统毎次在进行资源分配之前，先计算此次分配资源的安全性，若此次资源分配不会导致系统进入不安全状态则分配资源。否则不分配资源，让进程等待。

银行家算法在避免死锁上非常有效，但是需要在进程运行前就知道其所需资源的最大值，且进程数也通常不是固定的，因此很难实现。

银行家当中的数据类型如下：

- 已分配给进程的资源：Allocation
    
- 进程总共需要的资源数：Claim
    
- 进程还需要的资源数：Need
    
- 资源池(空闲资源数)：Available
    

银行家算法分配系统资源的原则如下：

- 当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳该进程。
    
- 进程可以分期请求资源，但请求的总数不能超过最大需求量。
    
- 当系统空闲的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里得到资源。
    
- 当系统空闲的资源能满足进程尚需资源数时，必须测试系统现存的资源能否满足该进程尚需的最大资源数，如果不能满足最大需求资源数也要推迟分配。