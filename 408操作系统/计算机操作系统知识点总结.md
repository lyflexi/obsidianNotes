# 一、操作系统概述
## 1.1 操作系统的基本功能

1. 统一管理计算机资源：处理器资源，IO设备资源，存储器资源，文件资源;
2. 实现了对计算机资源的抽象：IO设备管理软件提供读写接口，File文件管理软件提供操作文件接口;
3. 提供了用户与计算机之间的接口：GUI（图形用户界面），命令形式，系统调用形式。

## 1.2 操作系统的特征

最基本的特征，互为存在条件：并发，共享；

（1）并行：指两个或多个事件可以在同一个时刻发生，多核CPU可以实现并行，一个cpu同一时刻只有一个程序在运行；

（2）并发：指两个或多个事件可以在同一个时间间隔发生，用户看起来是每个程序都在运行，实际上是每个程序都交替执行。

（3）共享性：操作系统的中资源可供多个并发的程序共同使用，这种形式称之为资源共享。

- 互斥共享：当资源被程序占用时，其它想使用的程序只能等待。
- 同时访问：某种资源并发的被多个程序访问。

下面的虚拟和异步特性前提是具有并发性
（4）虚拟性：表现为把一个物理实体转变为若干个逻辑实体。
- 时分复用技术：资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源的利用率。
- 空分复用技术：用来实现虚拟磁盘（物理磁盘虚拟为逻辑磁盘，电脑上的C盘、D盘等）、虚拟内存（在逻辑上扩大程序的存储容量）等，提高资源的利用率，提高编程效率。
（5）异步性：在多道程序环境下，允许多个进程并发执行，但由于资源等因素的限制，使进程的执行以“停停走走”的方式运行，而且每个进程执行的情况（运行、暂停、速度、完成）也是未知的。

## 1.3 操作系统的中断处理
如果没有“中断”机制，那么一旦应用程序上CPU运行，只要应用程序没有结束，CPU就会一直运行这个应用程序，这样就没有并发了，一切都是串行执行了，效率极低

中断产生：
- 发生中断时，CPU立马切换到管态，开展管理工作；（管态又叫特权态，系统态或核心态，是操作系统管理的程序执行时，机器所处的状态。）
- 发生中断后，当前运行的进程回暂停运行，由操作系统内核对中断进行处理；

中断的分类：
1. 内中断（也叫“异常”、“例外”、“陷入”）------- 信号来源：CPU内部，与当前执行指令有关；
2. 外中断（中断）----------信号来源：CPU外部，与当前执行指令无关。

外中断的处理过程：
1. 每执行完一个指令后，CPU都需要检查当前是否有外部中断信号；
2. 如果检查到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC、各种通用寄存器）把他们存储在进程控制块PCB中；
3. 对于不同的中断信号，会进行不同的处理。具体而言，根据中断信号类型转入相应的中断处理程序；
4. 恢复原进程的CPU环境并退出中断，返回原进程继续执行。
# 二、进程管理PCB
进程的五状态模型：

就绪状态：其它资源（进程控制块、内存、栈空间、堆空间等）都准备好、只差CPU的状态。
执行状态：进程获得CPU，其程序正在执行。
阻塞状态：进程因某种原因放弃CPU的状态，阻塞进程以队列的形式放置。
创建状态：创建进程时拥有PCB但其它资源尚未就绪。
终止状态：进程结束由系统清理或者归还PCB的状态。

## 2.1 进程实体

为什么需要进程：

1. 进程是系统进行**资源分配和调度的基本单位**；
2. 进程作为程序独立运行的载体保障程序正常执行；
3. 进程的存在使得操作系统资源的利用率大幅提升。

进程控制块（PCB）：用于描述和控制进程运行的通用数据结构，记录进程当前状态和控制进程运行的全部信息，是进程存在的唯一标识。
### 2.1.1 进程VS线程
进程（Process）与线程（Thread）定位：
- 进程：系统进行资源分配和调度的基本单位。
- 线程：操作系统进行运行调度的最小单位。

进程和线程的主要差别在于它们是不同的操作系统资源管理方式，区别如下：
1. 内存空间与依存关系：系统在运行的时候会为每个进程分配不同的内存空间。而对于线程来说除了CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间共享当前进程的资源；还有线程不能够独立执行，必须依存在应用程序中,由应用程序提供多个线程执行控制；
2. 切换开销：进程的上下文切换时间开销远远大于线程上下文切换时间，耗费资源较大，效率要差一些；

jps全称Java Virtual Machine Process Status Tool，是Java提供的一个用来显示当前所有Java进程的命令脚本。与之对应，linux 系统里也有一个ps命令
Java的每一个程序，均独占一个Java虚拟机实例，且都是一个独立的进程，每个进程都有自己的id。jps命令的位置在 JAVA_HOME/bin/ 下，jps命令常用参数如下：
- 无参数（ -V ） 默认显示 pid、应用程序 main class 类名
- -q：只显示 pid
- -m：显示 pid、应用程序`main class`类名和传递给main方法的参数，在嵌入式jvm上可能是null
- -l：显示pid 和应用程序`main class`的完整包名或者 应用程序的jar路径
- -v：显示pid 、应用程序`main class`类名和传递给 jvm 的参数
![[Pasted image 20231225133353.png]]

使用`man jps`可以查看 jps命令手册
![[Pasted image 20231225133358.png]]

### 2.1.2 线程VS协程

我们知道操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。当系统线程较少的时候没有什么问题，但是当线程数量非常多的时候，却产生了问题。

- 一是系统线程会占用非常多的内存空间，
- 二是过多的线程切换会占用大量的系统时间
协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。
- ==协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程。==
- ==协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。==
![[Pasted image 20231225133420.png]]
我们只需要启动100个线程，每个线程上运行100个协程，这样不仅减少了线程切换开销，而且还能够同时处理10000个读取数据库的任务，很好的解决了上述任务。

==需要注意的是阻塞了协程就相当于阻塞了当前线程（其它绑定在该线程上面的协程都得不到调度），所以协程只有和异步IO结合起来，才能发挥最大的威力。==
## 2.2 临界资源问题
临界资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。

**生产者消费者问题**：并发修改问题
**哲学家进餐问题**：死锁问题
### 2.2.1并发问题
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。死锁的四个必要条件如下：

1. 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
    
2. 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
    
3. 不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
    
4. 循环等待条件：指在发生死锁时，必然存在一个进程—资源的环形链，即进程集合`{P0，P1，P2，···，Pn}`中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。若干个进程间形成了首尾相接循环等待资源的情况
    

### 2.2.2死锁问题
#### 2.2.2.1如何预防死锁

1. 破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的(临界资源需要互斥访问)
2. 破坏请求与保持条件：一次性申请所有的资源。
3. 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
4. 破坏循环等待条件：靠按序申请资源来预防。进程在申请资源时必须按照序号递增的顺序进行资源的申请，释放资源则反序释放。

#### 2.2.2.2死锁避免算法

银行家算法是一种死锁避免算法，该算法允许进程动态申请资源。系统毎次在进行资源分配之前，先计算此次分配资源的安全性，若此次资源分配不会导致系统进入不安全状态则分配资源。否则不分配资源，让进程等待。

银行家算法在避免死锁上非常有效，但是需要在进程运行前就知道其所需资源的最大值，且进程数也通常不是固定的，因此很难实现。

银行家当中的数据类型如下：
- 已分配给进程的资源：Allocation
- 进程总共需要的资源数：Claim
- 进程还需要的资源数：Need
- 资源池(空闲资源数)：Available
    

银行家算法分配系统资源的原则如下：

- 当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳该进程。
- 进程可以分期请求资源，但请求的总数不能超过最大需求量。
- 当系统空闲的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里得到资源。
- 当系统空闲的资源能满足进程尚需资源数时，必须测试系统现存的资源能否满足该进程尚需的最大资源数，如果不能满足最大需求资源数也要推迟分配。
## 2.3 同步策略

### 2.3.1 进程同步的方法（重要）
进程同步的作用：对竞争资源在多进程间进行使用次序的协调，使得并发执行的多个进程之间可以有效使用资源和相互合作。

进程间同步的四原则：
1. 空闲让进：资源无占用，允许使用；
2. 忙则等待：资源被占用，请求进程等待；
3. 有限等待：保证有限等待时间能够使用资源；
4. 让权等待：等待时，进程需要让出CPU。

### 2.3.2 线程同步的方法（重要）

线程同步的方法：

1.互斥锁：互斥锁是最简单的线程同步的方法，也称为互斥量，处于两态之一的变量：解锁和加锁，两个状态可以保证资源访问的串行。原子性：指一系列操作不可被中断的特性，要么全部执行完成，要么全部没有执行。
2.自旋锁：自旋锁是一种多线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用，自旋锁不会让出CPU，是一种忙等待状态，即死循环等待锁被释放，自旋锁的效率远高于互斥锁。特点：避免了进程或者线程上下文切换的开销，但是不适合在单核CPU使用。
3.读写锁：是一种特殊的自旋锁，允许多个读操作同时访问资源以提高读性能，但是对写操作是互斥的，即对多读少写的操作效率提升很显著。
4.条件变量：是一种相对比较复杂的线程同步方法，条件变量允许线程睡眠，直到满足某种条件，当满足条件时，可以给该线程信号通知唤醒。




