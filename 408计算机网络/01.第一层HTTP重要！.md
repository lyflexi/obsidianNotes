由于http协议是无状态的，每一次请求都无状态。当一个用户通过用户名和密码登录了之后，他的下一个请求不会携带任何状态，应用程序无法知道他的身份，那就必须重新认证。因此我们希望用户登录成功之后的每一次http请求，都能够保存他的登录状态。
- Authentication：认证，指的是验证用户的身份，例如你希望以小A的身份登录，那么应用程序需要通过用户名和密码确认你真的是小A。
- Authorization：授权，指的是确认你的身份之后提供给你权限，例如用户小A可以修改数据，而用户小B只能阅读数据。
目前主流的用户认证方法有基于session和基于token两种方式
# Session
基于session的认证流程如下：
![[Pasted image 20240327190217.png]]
1. 用户输入其登录信息，服务器验证信息是否正确，并创建一个session，然后将其存储在数据库中，如redis或者MySQL
2. 服务器为用户生成一个sessionId，客户端将sesssionId放置在用户浏览器的Cookie中
3. 在后续客户端的请求中，会根据数据库验证sessionID，如果有效，则接受请求并返回相应
客户端Cookie 被禁用怎么办？最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。
# jwt-token
jwt：JSON Web Token，又叫令牌，流程跟session方式很像：
1. 用户输入其登录信息，服务器验证信息是否正确，但这第一步并没有使用到jwt，因为jwt是不安全的
2. 服务器用私钥进行签名，返回已签名的token
3. token储在客户端，例如存在local storage或cookie中
4. 之后的HTTP请求都将token添加到请求头里
5. 服务器解码JWT，并且如果令牌有效，则接受请求
6. 一旦用户注销，令牌将在客户端被销毁
基于session和基于jwt的方式的主要区别如下：
- 用户的状态保存的位置，session是保存在服务端的，而jwt是保存在客户端的。
- 经过编码之后导致jwt非常长，cookie的限制大小一般是4k，cookie很可能放不下，所以jwt一般放在local storage里面。
- 每一次http请求都会把jwt携带在Header里面，http请求的Header可能比Body还要大。而sessionId只是很短的一个字符串，因此使用jwt的http请求比使用session的开销大得多。`
一个完整的jwt实际上就是一个字符串，它由三部分组成:
- 头部head、
- 载荷Payload、
- 签名signature
这三个部分都是json格式
头部head用于描述关于该JWT的最基本的信息，例如下面说明了这是一个JWT，并且我们所用的签名算法是HS256算法。
```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```
载荷Payload可以用来放一些不敏感的信息。
```json
{
    "iss": "John Wu JWT",
    "iat": 1441593502,
    "exp": 1441594722,
    "aud": "www.example.com",
    "sub": "jrocket@example.com",
    "from_user": "B",
    "target_user": "A"
}
```
这里面的前五个字段都是由JWT的标准所定义的。
- `iss`: 该JWT的签发者
- `sub`: 该JWT所面向的用户
- `aud`: 接收该JWT的一方
- `exp`(expires): 什么时候过期，这里是一个Unix时间戳
- `iat`(issued at): 在什么时候签发的

把头部和载荷分别进行Base64编码之后得到两个字符串，然后再将这两个编码后的字符串用英文句号`.`连接在一起（头部在前），形成新的字符串：
```shell
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0
```

服务器使用私钥secret将上面拼接完的字符串用HS256算法进行加密，得到签名
```shell
rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
```
把这个签名拼接在刚才的字符串后面就能得到完整的jwt，返回给客户端。
```shell
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0
.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
```
由于jwt的头部和载荷都是使用base64编码的，并没有加密，是透明的，因此jwt中不能直接存储username或者password等敏感数据，使用签名仅仅是为了保证服务器返回的token不被篡改。
- 因此，虽然可以从每次请求的token中解析出用户ID、角色、权限等信息方便进行下次授权，但不能解析出敏感信息如密码。
- 密码应该在初次登录过程中使用安全的方式如HTTPS传输，并在服务器端进行验证，而不是存储在 JWT 中。
# 加密encryption
HTTPS与Http的区别如下：
- 端口 ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。
- 协议：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上。所以说，HTTP 安全性没有 HTTPS 高
- 资源： HTTPS 比 HTTP 耗费更多服务器资源。
HTTPS的加密策略分为对称加密和非对称加密
- 对称加密【快】：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；
- 非对称加密【慢】：密钥成对出现，加密解密使用不同密钥，相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。
因此非对称加密就有两种加解密策略，但前提是由服务器生成公私钥并由服务器自己保存绝密的私钥，只是把公钥公开。
1. 公钥加密私钥解密，称之为非对称加密，真实数据不可见，典型应用为使用https加密完成用户名密码的认证
2. 私钥加密公钥解密，称之为数字签名。数据相当于透明传输公钥持有者都可见，做数字签名仅仅是为了防篡改，典型应用为jwt生成技术

想象这样一个场景：苏珊S给鲍勃B写信，鲍勃给苏珊回信。
1. 服务器生成公私钥
该场景下，鲍勃就相当于服务器，并生成了公钥和私钥。

鲍勃把公钥送给他的朋友们----帕蒂、道格、苏珊----每人一把。（公钥不怕泄漏，要不怎么叫公钥）
![[Pasted image 20240131154920.png]]

2. 客户端使用公钥加密，发送信件，类似于保护用户名密码进行登录认证

苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。

鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。
![[Pasted image 20240131154932.png]]
# 数字签名Signature
服务器使用私钥加密，回复信件，类似于服务器生成jwt返回给客户端
1. 鲍勃给苏珊回信，决定采用“数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。
![[Pasted image 20240131154937.png]]

2. 然后，鲍勃使用私钥，对这个摘要加密，生成“数字签名”（signature）。
![[Pasted image 20240131154942.png]]
3. 鲍勃将这个签名，附在信件下面，一起发给苏珊。
![[Pasted image 20240131154950.png]]

4. 苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。
![[Pasted image 20240131154958.png]]

5. 苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。
![[Pasted image 20240131155004.png]]

# 证书中心CA

复杂的情况出现了，公私钥成对的被掉包了：

道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。
同时，道格冒充鲍勃用自己的私钥做成“数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。
![[Pasted image 20240131155009.png]]

后来，鲍勃想到了一个办法，去找“证书中心”（certificate authority，简称CA），为自己的公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成新的数字签名颁发给服务器鲍勃。我们认为证书机构是绝对安全的，因此我们称该新的数字签名为数字证书（digital certificate，简称DC）
![[Pasted image 20240131155013.png]]

鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。
![[Pasted image 20240131155018.png]]
苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，
苏珊再继续拆包，用鲍勃的公钥解密出真实数据摘要
![[Pasted image 20240131155022.png]]

# 完整的internet认证流程

下面，我们看一个internet是如何应用数字证书DC的案例：

1. 首先，客户端使用公钥对敏感信息如密码贾母，向服务器发出加密认证请求。
![[Pasted image 20240131155028.png]]

2. 服务器发现认证成功，用自己的私钥把网页加密成数字签名，连同CA提供的数字证书，一起发送给客户端。
![[Pasted image 20240131155033.png]]

3. 客户端（浏览器）的“证书管理器”，有“受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。
    
![[Pasted image 20240131155037.png]]

4. 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。
![[Pasted image 20240131155042.png]]

5. 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。
![[Pasted image 20240131155048.png]]

6. 如果数字证书是可靠的，客户端就可以使用CA的公钥对证书解密，得到服务器的数字签名
7. 客户端进一步拆包，用服务器提供的公钥，对服务器的数字签名进行解密，得到最终的真实摘要数据
8. 此后客户端与服务器之间的认证操作就算完成了，可以安心的进行后续的授权操作了。
![[Pasted image 20240131155054.png]]
# 长连接，短连接

在 HTTP/1.0 中默认使用短连接。也就是说，客户端每发起一个请求，都要新建一次 TCP 连接（三次握手），增加了通信开销。
![[Pasted image 20240131154020.png]]
为了解决上述 TCP 连接问题，HTTP/1.1 默认使用长连接，也叫持久连接。使用长连接的 HTTP 协议，会在响应头加入这行代码：
```shell
Connection:keep-alive 
```
在使用长连接的情况下，当一个网页打开完成后，TCP 连接不会关闭，客户端再次访问这个服务器时，HTTP会继续使用这一条已经建立的连接。 HTTP/1.1 持续连接更细化的能力有非流水线方式和流水线方式 。
1. 流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。
2. 与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。
最后，长连接的持续时间可以通过Keep-Alive参数来控制
```shell
Keep-Alive
```
# 长轮询，短轮询

首先我们想象一个业务场景，现在有一个商品正在销售（正常网购场景，并非秒杀）。商品的旁边要显示它的库存量，并且这个库存量是要时实变化的，那我们该怎么处理。我们可以去编写一个JS函数，每一秒就去查询一次数据，然后把得到的结果在界面中渲染，进行刷新。这可行，但是有些缺点：即使没有消息，服务器也会每隔 10 秒被请求轰炸一次，即使用户切换到其他地方或者处于休眠状态，也是如此。就性能而言，这是一个很大的负担。以上就是短轮询

长轮询这个时候就出现了，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化才会返回，否则就一直等到超时为止。
![[Pasted image 20240327183244.png]]
而对于客户端来说，不管是长轮询还是短轮询，客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。

如果连接丢失，可能是因为网络错误，浏览器会立即发送一个新请求。
实现长轮询的客户端 `subscribe` 函数的示例代码：
```javascript
async function subscribe() {  
    let response = await fetch("/subscribe");  
  
    if (response.status == 502) {  
        // 状态 502 是连接超时错误，  
        // 连接挂起时间过长时可能会发生，  
        // 远程服务器或代理会关闭它  
        // 让我们重新连接  
        await subscribe();  
    } else if (response.status != 200) {  
        // 一个 error —— 让我们显示它  
        showMessage(response.statusText);  
        // 一秒后重新连接  
        await new Promise(resolve => setTimeout(resolve, 1000));  
        await subscribe();  
    } else {  
        // 获取并显示消息  
        let message = await response.text();  
        showMessage(message);  
        // 再次调用 subscribe() 以获取下一条消息  
        await subscribe();  
    }  
}  
  
subscribe();
```
使用长连接要小心，某些服务器架构是每个连接对应一个进程，导致进程数和长连接数一样多，而每个进程都会消耗相当多的内存。因此，过多的长连接会消耗掉全部内存。
# 负载均衡
正向代理(Proxy)在网络上是用来代理客户端(Client)的，而反向代理(Reverse Proxy)在网络上是用来代理(Server)的。

1. 通常情况下，咱们作为客户端(Client)，访问网络上的资源，都是发送请求到互联网(Internet)，之后导向相应的服务端(Server)获取资源。这属于没有加任何代理的网络访问
![[Pasted image 20240131154447.png]]
2. 正向代理(Proxy)，就是指在Client和Internet之间加一个中间服务，这个服务作为Client的代理人，拦截所有Client发出去的通讯，以代理人的身份再统一发出，这样的好处和应用场景是：
	- Proxy可以隐藏Client的IP, 暴露出去只是Proxy自己的IP，从而保护Client的隐私安全。
	- Proxy可以作为缓存，当有相同资源的请求时，可以直接返回缓存内容，提高响应速度。
	- Proxy可以作为过滤，限制或者阻断访问Internet上面一些特定内容。
	- Proxy可以作为跳板(比如VPN)，科学上网
![[Pasted image 20240131154508.png]]
3. 反向代理(Reverse Proxy), 就是指在Internet和Web Server之间加上一个中间服务，这个服务作为Web Server的代理人，拦截所有发给Web Server的请求，然后再统一分发给代理的Web Servers, 避免Internet网络流量直接发给Web Server。这样做的好处和应用场景是：
	- ReverseProxy可以隐藏WebServerIP, 只有反向代理的IP暴露网络, 从而保护WebServer。
	- ReverseProxy可以作为LoadBalancer，合理分配流量到集群里的WebServer。比如nginx和api-gateway
	- ReverseProxy可以作为网站静态内容的缓存，大大提高响应速度并减轻WebServer负担。
	- ReverseProxy可以代为处理SSL加密(计算量较大)，减轻WebServer的负担。
![[Pasted image 20240131154538.png]]
