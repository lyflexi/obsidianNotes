TCP 是面向连接的、可靠的、基于字节流的传输层通信协议，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。
![[Pasted image 20240131162530.png]]

- 面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- 字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。
# TCP头部结构
- 序列号SeqNum：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就累加一次。
- 确认应答号ACKNum：指下一次期望收到的数据的序列号。
- 除了SeqNum和ACKNum之外，TCP还有四个控制位
	- ==SYN：该位为 1 时，表示希望建立连接==
	- ==ACK：该位为 1 时，确认应答的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。==
	- FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。
	- RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
![[Pasted image 20240131162229.png]]
# TCP建立连接-三次握手
初始状态，服务端处于 LISTEN 状态表示主动监听某个端口
1. 客户端会随机初始化序号SeqNum_Client，同时把SYN控制位置为 1 表示希望建立连接。
2. 服务端也是随机初始化自己的序号SeqNum_Server，然后把AckNum_Server置为SeqNum_Client+1，接着把SYN和ACK控制位置都置为 1。
3. AckNum_Client置为SeqNum_Server+1，然后ACK控制位置为 1，此时客户端终于处于ESTABLISHED状态。服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。
上面的过程中，前两次握手是不可以携带数据的，第三次握手是可以携带数据的，这是因为在第三次握手中，双方已经互相确认了彼此的接收能力和发送能力，因此可以开始进行数据传输。这种允许在连接建立的同时发送数据的机制有助于提高网络效率，因为它避免了在连接建立后再次进行数据传输的延迟。这也是面试常问的题。
![[Pasted image 20240131162757.png]]
为什么要进行三次握手？当请求在网络中阻塞，客户端迟迟没有接收到服务器的响应，客户端就会重新发送请求建立连接 ，假如没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。
# TCP断开连接-四次挥手
双方都可以主动断开连接，假设以客户端主动关闭连接为例，四次挥手的过程如下图：
1. 客户端打算关闭连接，发送FIN报文
2. 服务端响应ACK报文
3. 服务端发送FIN报文，之后服务端进入 LAST_ACK 状态。这是多了一次握手的关键。
4. 客户端最后回一个ACK 应答报文，进入TIME_WATI状态，并经过 2MSL时间后，才会进入 CLOSED 状态。
为什么要四次挥手？因为服务器收到客户端的 FIN 报文时，仅仅表示客户端不再发送数据了但是还可能接收数据。所以服务端可以继续处理和发送数据，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。这也是服务器LAST_ACK状态状态的由来
![[Pasted image 20240131172043.png]]
客户端为什么要等于2MSL才进入CLOSE？

MSL 的单位是时间一般是30 秒，表示 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经自然消失在网络中了。

TIME_WAIT 等于 2 倍的 MSL，比较合理的解释是允许最后的ACK报文丢失一次，如果服务器方没有收到最后的 ACK 报文（1MSL），就会重发 FIN 报文（再次抵达客户端也要1MSL），因此一共2MSL

另外，客户端只要收到服务器发来的FIN之后，2MSL 时间将重新计时。


TIME_WAIT 过多有什么危害？过多的 TIME-WAIT 状态主要的危害有两种：
- 对客户端的影响：一个 TCP 连接至少消耗「发起连接方」的一个本地端口；如果「发起连接方」的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。端口资源是有限的，因为端口就 65536 个
- 对服务端的影响：因为服务端只监听一个端口，不会因为 TCP 连接过多而导致端口资源受限。但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。


