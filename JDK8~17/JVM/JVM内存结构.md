而JVM的内存结构，指的就是JVM定义的「运行时数据区域」
运行时数据区域分为了5大块：方法区、堆、程序计数器、虚拟机栈、本地方法栈
- 线程私有区：虚拟机栈（支持当前线程调用方法的深度），程序计数器
- 线程共享区：堆区，方法区
- c语言能力：本地方法栈

![[Pasted image 20231226110450.png]]

# 程序计数器-用于线程间切换

Java是多线程的语言，我们知道假设线程数大于CPU数，就很有可能有「线程切换」现象，切换意味着「中断」和「恢复」，那自然就需要有一块区域来保存「当前线程的执行信息」

所以，程序计数器就是用于记录各个线程执行的字节码的地址（分支、循环、跳转、异常、线程恢复等都依赖于计数器）

# 虚拟机栈-保存局部变量

每个线程在创建的时候都会创建一个「虚拟机栈」，每次方法调用都会在栈中创建一个「栈帧」。每个「栈帧」会包含几块内容：
- 局部变量表，所以方法中局部变量保存在栈中
- 操作数栈，保存部分变量的计算结果
- 动态连接，参与了方法的实际调用
- 返回地址，参与了方法的返回
![[Pasted image 20231225150724.png]]
其中运行时元数据指的是MarkWord
# 本地方法栈-保存c语言

本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。这里的「本地方法」指的是「非Java方法」，一般本地方法是使用C语言实现的。

# 方法区-保存类信息

在JDK8中，已经用「元空间」来替代了「永久代」，并以本地直接内存作为「方法区」的实现，JVM 不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。==同时把「静态常量池」和「运行时常量池」转移到了「堆」内存中进行存储（对于「物理分区」来说「静态常量池」和「运行时常量池』就属于堆）==
- 静态常量池主要存储的是「字面量」以及「符号引用」等信息，静态常量池也包括了我们说的「字符串常量池」。
- 运行时常量池存储的是「类加载」时生成的「直接引用」等信息。
因此目前方法区中只剩下了类相关信息：
- 类的版本、
- 类的字段、
- 类的方法、
- 类的接口
- 类的父类
![[Pasted image 20231226110534.png]]
# 堆-保存成员变量

「堆」是线程共享的区域，保存了类的成员变量信息，在JDK8中静态成员变量也存储于堆区

「堆」被划分为「新生代」和「老年代」，「新生代」又被进一步划分为 Eden 和 Survivor 区，并且 Survivor 由 From Survivor 和 To Survivor 组成。将「堆内存」分开了几块区域，主要跟「内存回收」有关（垃圾回收机制）
![[Pasted image 20231226110548.png]]


**延申内容：JVM内存结构和Java内存模型有啥区别？**
他们俩没有啥直接关联，Java内存模型是跟「并发」相关的，它是为了屏蔽底层细节而提出的规范，希望在上层(Java层面上)在操作内存时在不同的平台上也有相同的效果。Java内存结构（又称为运行时数据区域），它描述着当我们的class文件加载至虚拟机后，各个分区的「逻辑结构」是如何的，每个分区承担着什么作用。