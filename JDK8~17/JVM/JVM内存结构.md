而JVM的内存结构，指的就是JVM定义的「运行时数据区域」
运行时数据区域分为了5大块：方法区、堆、程序计数器、虚拟机栈、本地方法栈
- 线程共享区：堆区，方法区
- 线程隔离区：虚拟机栈，本地方法栈，程序计数器

![[Pasted image 20231226110450.png]]

# 程序计数器

Java是多线程的语言，我们知道假设线程数大于CPU数，就很有可能有「线程切换」现象，切换意味着「中断」和「恢复」，那自然就需要有一块区域来保存「当前线程的执行信息」

所以，程序计数器就是用于记录各个线程执行的字节码的地址（分支、循环、跳转、异常、线程恢复等都依赖于计数器）

# 虚拟机栈

每个线程在创建的时候都会创建一个「虚拟机栈」，每次方法调用都会创建一个「栈帧」。每个「栈帧」会包含几块内容：==局部变量==表、操作数栈、动态连接和返回地址
![[Pasted image 20231226110504.png]]

了解了「虚拟机栈」的组成后，也不难猜出它的作用了：它保存方法了局部变量、部分变量的计算并参与了方法的调用和返回。

# 本地方法栈

本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。这里的「本地方法」指的是「非Java方法」，一般本地方法是使用C语言实现的。

# 方法区

在JDK8中，已经用「元空间」来替代了「永久代」，并以本地直接内存作为「方法区」的实现，JVM 不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。==同时把「静态常量池」和「运行时常量池」转移到了「堆」内存中进行存储（对于「物理分区」来说「静态常量池」和「运行时常量池』就属于堆）==
- 静态常量池主要存储的是「字面量」以及「符号引用」等信息，静态常量池也包括了我们说的「字符串常量池」。
- 「运行时常量池」存储的是「类加载」时生成的「直接引用」等信息。
剩下方法区中主要是用来存放已被虚拟机加载的「类相关信息」：
- 类信息包括了
- 类的版本、
- 类的字段、
- 类的方法、
- 类的接口
- 类的父类
![[Pasted image 20231226110534.png]]
# 堆

「堆」是线程共享的区域，几乎类的实例和数组分配的内存都来自于它。

「堆」被划分为「新生代」和「老年代」，「新生代」又被进一步划分为 Eden 和 Survivor 区，并且 Survivor 由 From Survivor 和 To Survivor 组成。将「堆内存」分开了几块区域，主要跟「内存回收」有关（垃圾回收机制）
![[Pasted image 20231226110548.png]]


**延申内容：JVM内存结构和Java内存模型有啥区别？**
他们俩没有啥直接关联，Java内存模型是跟「并发」相关的，它是为了屏蔽底层细节而提出的规范，希望在上层(Java层面上)在操作内存时在不同的平台上也有相同的效果。Java内存结构（又称为运行时数据区域），它描述着当我们的class文件加载至虚拟机后，各个分区的「逻辑结构」是如何的，每个分区承担着什么作用。