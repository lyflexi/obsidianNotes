这次来聊聊G1垃圾收集器，7款经典的垃圾收集器与垃圾分代之间的关系：

- 新生代收集器： Serial、 ParNeW、Parallel Scavenge；
    
- 老年代收集器： Serial Old、 Parallel Old、 CMS；
    
- 整堆收集器： G1是JDK 9以后的默认垃圾回收器，CMS已经在JDK 9中被标记为废弃（deprecated）
    
![[Pasted image 20231226140006.png]]

G1收集器可以理解为在CMS垃圾收集器上进行”升级”，在过去CMS的停顿时间是「不可预知的」，而G1 垃圾收集器可以给你设定一个你希望Stop The Word 停顿时间，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。即可允许的收集时间。

在G1垃圾收集器的世界上，G1将堆空间分为若干个区域（Region）：
- ==这些区域逻辑包含年轻代和老年代，但是从整个堆的物理结构上看G1不要求整个Eden区、Survivor区和Old区是连续的，也不再坚持固定大小和固定数量。==
- G1中，还有一种叫 Humongous（大对象）区域，其实就是用来存储特别大的对象，如果超过1. 5个region，就放到H，如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。
![[Pasted image 20231226140205.png]]
# 为什么G1要划分Region

其实稍微想一下，也能理解为什么要将「整个堆空间」进行「逻辑细分」成不同的Region

以前的垃圾收集器都是对堆进行「物理」划分（整个Eden区、Survivor区和Old区是连续的，且分区大小和数量是固定的），如果堆空间（内存）大的时候，每次进行「垃圾回收」都需要对一整块大的区域进行回收，那收集的时间是不好控制的。==而G1将堆空间划分为一个个小Regin之后，那对这些「小区域」回收就容易控制它的「收集时间」了==
![[Pasted image 20231226140224.png]]
# G1收集器的执行过程

那我大概了解了。那要不你讲讲它的GC过程呗？

嗯，在G1收集器中，可以主要分为有Minor GC(Young GC)和Mixed GC，也有些特殊场景可能会发生Full GC

## Minor GC

那我就直接说Minor GC先咯？

G1的Minor GC其实触发时机跟其他垃圾收集器都是一样的，等到Eden区满了之后，会触发Minor GC。Minor GC同样也是会发生Stop The World的。

但是要补充说明的是：在G1的世界里，==新生代和老年代所占整个堆的空间比例==是没那么固定的，这个比例==会动态根据「最大停顿时间」进行调整==，所以，动态地改变年轻代Region的个数可以「控制」Minor GC的开销。

这块要知道会给我们提供参数进行配置就好了。

Minor GC我认为可以简单分为为三个步骤：根扫描、处理跨代引用 RSet、复制对象CSet
![[Pasted image 20231226140500.png]]
### 根扫描

第一步应该很好理解，因为这跟之前CMS是类似的，可以理解为初始标记的过程

### 处理跨代引用 RSet

第二步涉及到「Rset」的概念

我们知道，传统Minor GC是通过「卡表」(cart table)来避免全表扫描老年代的对象，以此快速检索出被老年代跨代引用的新生代对象（该类新生代对象不能被执行Minor GC）。

同样的，在G1也有这种问题（毕竟也存在Minor GC）。而G1解决「跨代引用」的问题的存储一般叫做RSet

要记住，RSet这种存储在每个Region都会有，它记录着「其他Region引用了当前Region的对象关系」
- 对于年轻代的Region，它的RSet 只保存了来自老年代的引用（年轻代的Region没有必要再存储来自年轻代的引用关系，因为自己都要做Minor GC了）
- 而对于老年代的 Region 来说，它的 RSet 也只会保存老年代对它的引用（在G1垃圾收集器，老年代回收之前，都会先对年轻代进行回收，所以没必要保存年轻代对老年代的引用关系）
![[Pasted image 20231226140548.png]]
==因此Minor GC，无非就是依据年轻代Region当中的RSet的信息，将来自老年代的跨代引用都加入到GC Roots下，避免此类年轻代Region被回收掉==

### 复制对象 CSet

到了第三步也挺好理解的：把扫描之后存活的对象往「空的Survivor区」或者「老年代」存放，其他的Eden区进行清除。


这里要提下的是，在G1还有另一个名词，叫做CSet，它的全称是 Collection Set，保存了一次GC中「将执行垃圾回收」的Region集合。CSet中的所有存活对象都会被转移到别的可用Region上
![[Pasted image 20231226140805.png]]

在Minor GC 的最后，会处理下软引用、弱引用、JNI Weak等引用，结束收集

## **Mixed GC** 重点与CMS对比

**我记得你前面提到了Mixed GC ，要不来聊下这个过程呗？**

好，没问题的。
- 当堆空间的占用率达到一定阈值后会触发Mixed GC（默认45%，由参数决定）
- Mixed GC 依赖「全局并发标记阶段」统计后的Region数据
「全局并发标记」它的过程跟CMS非常类似，步骤大概是：初始标记（STW）、并发标记、最终标记（STW）以及清理（STW），==因为G1是混合清理Mixed GC，最后清理的时候必然涉及年轻代的标记复制清理，标记复制是不支持用户线程并发的，因此清理阶段不支持并发，这一点与CMS不同==
![[Pasted image 20231226141053.png]]

还是想说明下：Mixed GC它一定会回收年轻代，并会采集部分老年代的Region进行回收的，所以它是一个“混合”GC。同时我们将G1与CMS的处理过程尤其是CMS的两个异常清除做对比，上次我记得说过，CMS垃圾收集器有两个弊端，会产生内存碎片&&浮动垃圾，以至于分别导致Promotion failed异常和Concurrent mode failure异常。==提前剧透，G1解决了内存碎片问题！！！==

1. 首先是「初始标记」，这个过程是「共用」了Minor GC的 Stop The World（Mixed GC 一定会发生 Minor GC），复用了Minor GC的「扫描GC Roots」的操作。在这个过程中，老年代和新生代都会扫。总的来说，「初始标记」这个过程还是比较快的，毕竟没有追溯遍历嘛
2. 接下来就到了「并发标记」，唯一的支持用户线程并发阶段，这个阶段不会Stop The World。GC线程与用户线程一起执行，GC线程负责收集各个 Region 的存活对象信息。从GC Roots往下追溯，查找整个堆存活的对象，比较耗时
3. 接下来就到「重新标记」阶段，跟CMS类似，标记那些在「并发标记」阶段发生变化的对象。是不是很简单？且慢！！！CMS在「重新标记」阶段，应该会以所有的线程栈和整个年轻代作为root重新扫描以此来解决并发标记问题的，但是据我了解，G1好像不是这样的。==G1 确实不是这样的，在G1中解决「并发标记」阶段导致引用变更的问题，使用的是SATB算法。==
    -  可以简单理解为：在GC 开始的时候，它为存活的对象做了一次「快照」。然后在「重新标记」阶段只扫描着块「发生过变化」的引用（与快照不一致的引用），看有没有对象还是存活的，加入到「GC Roots」上
        ![[Pasted image 20231226141419.png]]
    
    -  不过SATB算法==是一个保守策略==，算法会产生一个小的问题，如果在开始时，G1就认为它是活的，那就在此次GC中不会对它回收，即便可能在「并发标记」上对象已经变为了垃圾。==所以，G1也有可能会存在「浮动垃圾」的问题==。但是总的来说，对于G1而言，问题不大（毕竟它不是追求一次把所有的垃圾都清除掉，而是注重对 Stop The World时间的把控）
4. 最后一个阶段就是「清理」，这个阶段也是会Stop The World的，主要清点和重置标记状态。一次回收未必是将所有的垃圾进行回收的，会根据「停顿预测模型」（其实就是设定的停顿时间），来决定本次GC回收多少Region。Mixed GC会选定所有的年轻代Region，部分「回收价值高」的老年代Region（回收价值高其实就是垃圾多）进行采集。
    ![[Pasted image 20231226141736.png]]
    -  在新生代Minor GC，G1 采用的仍然是并行的复制算法，所以同样会发生 Stop-The-World 的暂停。
    -  ==在老年代，大部分情况下都是并发标记，而整理（Compact）则是和新生代 GC 时捎带进行，所以不是整体性的整理，而是增量进行的。正因为整理算法，G1收集器避免了CMS的内存碎片的产生==。等等，不是说并发收集器为了满足用户线程和gc线程的并发存在，而不得不采用标记清除算法吗？为什么G1使用标记复制算法也能够满足并发性呢。可别忘了，在第二个阶段【并发标记】的时候可是支持并发的哟
## **full GC**

**那G1会什么时候发生full GC？**

如果在Mixed GC中无法跟上用户线程分配内存的速度，导致老年代填满无法继续进行Mixed GC，就又会降级到serial old GC来收集整个GC heap。不过这个场景相较于CMS还是很少的



本文总结(**G1垃圾收集器特点**)：

- 从原来的「物理」分代，变成现在的「逻辑」分代，将堆内存「逻辑」划分为多个Region
    
- 使用CSet来存储可回收Region的集合
    
- 使用RSet来处理跨代引用的问题（注意：RSet不保留 年轻代相关的引用关系）
    
- G1可简单分为：Minor GC 和Mixed GC以及Full GC
    
- 【Eden区满则触发】Minor GC 回收过程可简单分为：(STW) 扫描 GC Roots、更新&&处理Rset、复制清除
    
- 【整堆空间占一定比例则触发】Mixed GC 依赖「全局并发标记」，得到CSet(可回收Region)，就进行「复制清除」
    
- R大描述G1原理的时候，从宏观的角度看G1其实就是「**全局并发标记**」和「**拷贝存活对象**」
    
- 使用SATB算法来处理「并发标记」阶段对象引用可能会修改的问题
    
- 提供可停顿时间参数供用户设置（**G1会尽量满足该停顿时间来调整 GC时回收Region的数量**）