上次讲到JVM内存结构（运行时数据区域）提到了「堆」，然后是分了几块区域
- 「新生代」：又分为「Eden」和「Survivor」区，「survivor」区又分为「From Survivor」和「To Survivor」区
- 「老年代」
![[Pasted image 20231226115221.png]]

说到这里，我就想聊聊Java的垃圾回收机制了。我们使用Java的时候，会创建很多对象，但我们未曾「手动」将这些对象进行清除。而如果用C/C++语言的时候，用完是需要自己free(释放)掉的

那为什么在写Java的时候不用我们自己手动释放”垃圾”呢？原因很简单，JVM帮我们做了（自动回收垃圾）

我个人对垃圾的定义：只要对象不再被使用了，那我们就认为该对象就是垃圾，对象所占用的空间就可以被回收
![[Pasted image 20240224202747.png]]**那是怎么判断对象不再被使用的呢？**
# 引用计数法
常用的算法有两个「引用计数法」和「可达性分析法」

引用计数法思路很简单：当对象被引用则+1，但对象引用失败则-1。当计数器为0时，说明对象不再被引用，可以

==引用计数法难以处理循环引用的情况，即两个或多个对象之间相互引用，但是它们之间已经没有被外部引用的对象。这种情况下，对象的引用计数永远不会变为零，导致对象永远无法被回收，造成内存泄漏。==

# 可达性分析法

==另一种就是可达性分析法：==

- 它从「GC Roots」开始向下搜索，当对象到「GC Roots」都没有任何引用相连时，说明对象是不可用的，可以被回收
- 「GC Roots」是一组必须「活跃」的引用。从「GC Root」出发，程序通过直接引用或者间接引用，能够找到可能正在被使用的对象


**还是不太懂，那「GC Roots」一般是什么？你说它是一组活跃的引用，能不能举个例子，太抽象了。**

比如我们上次不是聊到JVM内存结构中的虚拟机栈吗，虚拟机栈里不是有栈帧吗，栈帧不是有局部变量吗？局部变量不就存储着引用嘛。那如果栈帧位于虚拟机栈的栈顶，是不是就可以说明这个栈帧是活跃的（换言之，是线程正在被调用的）。既然是线程正在调用的，那栈帧里的指向「堆」的对象引用，就一定是「活跃」的引用

所以，当前活跃的栈帧指向堆里的对象引用就可以是「GC Roots」

当然了，==能作为「GC Roots」除了上面说的虚拟机栈顶帧里的指向「堆」的对象引用==

- 还有，比如类的静态变量引用是「GC Roots」，
- 还有，被「Java本地方法」所引用的对象也是「GC Roots」等等…
    
![[Pasted image 20231226115414.png]]

回到理解的重点：「GC Roots」是一组必须「活跃」的「引用」，只要跟「GC Roots」没有直接或者间接引用相连，那就是垃圾

# 垃圾回收策略

## 标记清除法

垃圾回收的第一步就是「标记」，标记哪些没有被「GC Roots」引用的对象。
![[Pasted image 20231226115427.png]]

标记完之后，我们就可以选择直接「清除」，只要不被「GC Roots」关联的，都可以干掉。整个过程非常简单粗暴，但也存在很明显的问题，
直接清除会有「内存碎片」的问题：可能清除完垃圾还剩余10M的空余内存，但程序申请9M内存空间却申请不下来（10M的内存空间是垃圾清除后的，不连续的）
![[Pasted image 20231226115503.png]]

## 标记复制法

那解决「内存碎片」的问题也比较简单粗暴，「标记」完，不直接「清除」。

而是把「标记」存活的对象「复制」到另一整块空闲的空间，复制完了之后，直接把原有的整块空间给干掉！这样就没有内存碎片的问题了

这种做法缺点又很明显：内存利用率低，得有一块新的区域给我复制(移动)过去

## 标记整理法

还有一种「折中」的办法，我未必要有一块「大的完整空间」才能解决内存碎片的问题，我只要能在「当前区域」内进行移动

把存活的对象移到一边，把垃圾移到一边，那再将垃圾一起删除掉，不就没有内存碎片了嘛

这种专业的术语就叫做「整理」
![[Pasted image 20231226115509.png]]

# 分代垃圾回收器

## 为什么要分代回收垃圾

经过研究表明：大部分对象的生命周期都很短，而只有少部分对象可能会存活很长时间。

由于「垃圾回收」是会导致「stop the world」（应用停止访问），==为了使「stop the world」的频率尽可能的低，以及提高并发式GC所能应付的内存分配速率==。在很多的垃圾收集器上都会在「物理」或者「逻辑」上，把这两类对象进行区分，死得快的对象所占的区域叫做「年轻代」，活得久的对象所占的区域叫做「老年代」

>Stop the world：回收垃圾的时候，用户程序是有短暂的时间停止运作。不然JVM在回收的时候，用户线程还继续分配修改引用，JVM怎么搞


我们可以看下在JDK8生产环境及以下常见的垃圾回收器了

- 「年轻代」的垃圾收集器有：Seria、Parallel Scavenge、ParNew
    
- 「老年代」的垃圾收集器有：Serial Old、Parallel Old、CMS并发收集器

JDK9：全代垃圾收集器G1

看着垃圾收集器有很多，其实还是非常好理解的。Serial是单线程的，Parallel是多线程。这些算法没有什么新的思想，只是根据堆空间各个年代的特点对上述标记复制、标记整理或者标记清除算法进行合理的组合

- 比如在新生代中，每次收集都会有大量对象死去，所以可以选择「标记复制算法」，只需要付出少量对象的复制成本就可以完成每次垃圾收集。==所以在「堆内存」划分中，将年轻代划分出Survivor区（Survivor From 和Survivor To），目的就是为了有一块完整的内存空间供young gc进行拷贝(移动)，而新来的对象则放入Eden区。==
- 而老年代的对象存活几率是比较高的，而且没有额外的空间给他分配，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
## 年轻代的复制算法优化

复制算法是新生代的垃圾收集收集算法，基本思路是将新生代分为两个大小一样的内存区域，每次新对象会放置在其中的一块区域内。当该区域的大小不足以继续分配对象时，此时就会促发Minor GC,首先将存活的对象标记出来，然后将存活的对象转移到另一块内存区域中，这样可以比较紧凑地将对象排列在一起，减小了内存碎片。但是每次只能用一半的新生代，对内存的使用效率太低了！

复制算法的优化：Eden区和Survivor区
其实大多数对象存活周期非常短的，可能一次新生代垃圾回收，99%的对象都被回收了，所以真正的复制算法会进行优化，把新生代内存分为三块：一块Eden区和两块Survivor区，比例默认是8：1：1。
- 平时对象的分配都是分配在Eden区，当Eden区快满时触发垃圾回收，将存活的对象转移到其中一块Survivor区中，然后对Eden区进行清除。
- 等到Eden区再次填满时，Eden区域的存活对象和使用过的Survivor区域的存活对象转移到空的Survivor区域中，然后清除Eden区和之前的Survivor区。就这样始终保存一块Survivor是空的等待接受存活对象，循环使用三块内存。这样可用内存就变成了90%，而不是之前的50%
这也就是为什么新生代要划分为三块区域，这样做既能减少内存碎片，也能提高内存的使用效率。

## 晋升老年代标志

**我还想问问，就是，新创建的对象一般是在「新生代」嘛，那在什么时候会到「老年代」中呢？**

我认为简单可以分为两种情况：

- 1. 如果对象太大了，就会直接进入老年代（对象创建时就很大 || Survivor区没办法存下该对象）
- 2. 如果对象太老了，那就会晋升至老年代（动态的判定对象年龄，来决定何时进入老年代）
    - 第一次Minor GC，Eden-->survivor
    - 以后每发生一次Minor GC ，存活的对象年龄+1，达到默认值15则晋升老年代，这个数值可以通过-XX:MaxTenuringThreshold=n调整
![[Pasted image 20231226115924.png]]

# Minor GC如何避免全堆扫描！重要

**既然你又提到了Minor GC，那Minor GC 什么时候会触发呢？**

当Eden区空间不足时，就会触发Minor GC，Minor GC 就是「年轻代」的GC

**那在「年轻代」GC的时候，从GC Roots出发，那不也会扫描到「老年代」的对象吗？那那那..不就相当于全堆扫描吗？**

## 物理定位年轻代

这JVM里也有解决办法的。==HotSpot 虚拟机「老的GC」（G1以下）是要求整个GC堆在连续的地址空间上==。所以会有一条物理分界线（一侧是老年代，另一侧是年轻代），所以可以通过「地址」就可以判断对象在哪个分代上。当做Minor GC的时候，从GC Roots出发，如果发现「老年代」的对象，那就不往下走了（Minor GC对老年代的区域毫无兴趣）

我下面重新画下「堆内存」的图，因为它们的大小是有默认的比例的
![[Pasted image 20231226115915.png]]
## 利用卡表快速检索被老年代跨代引用

**但又有个问题，那如果「年轻代」的对象被「老年代」引用了（跨代引用），那时候肯定是不能回收掉「年轻代」的对象的**。**如何保证此时的「年轻代」对象不被回收的同时又避免全堆扫描呢？**

HotSpot虚拟机下 有「card table」（卡表）来避免全局扫描「老年代」对象
- 「堆内存」的每一小块区域形成「卡页/脏页」，当判断一个卡页中有存在对象被老年代(老不死的缠着我)跨代引用时，将这个页标记为「脏页」
- 卡表实际上就是卡页的集合。

那知道了「卡表」之后，就很好办了。每次Minor GC 的时候只需要去「卡表」==找到「脏页」，找到后加入至GC Root表示我是活跃的年轻代对象==，而不用去遍历整个「老年代」的对象了。
![[Pasted image 20231226120045.png]]


**本文总结**：
- **什么是垃圾**：只要对象不再被使用，那即是垃圾
- **如何判断为垃圾**：可达性分析算法和引用计数算法，JVM使用的是可达性分析算法
- **什么是GC Roots**：GC Roots是一组必须活跃的引用，跟GC Roots无关联的引用即是垃圾，可被回收
- **常见的垃圾回收算法**：标记清除、标记复制、标记整理
- **为什么需要分代**：大部分对象都死得早，只有少部分对象会存活很长时间。在堆内存上都会在物理或逻辑上进行分代，为了使「stop the world」持续的时间尽可能短以及提高并发式GC所能应付的内存分配速率。
- **Minor GC**：当Eden区满了则触发，从GC Roots往下遍历，年轻代GC不关心老年代对象
- **什么是card table**【卡表】：空间换时间（类似bitmap），能够避免扫描老年代的所有对应进而顺利进行Minor GC （案例：老年代对象持有年轻代对象引用）
- **堆内存占比**：年轻代占堆内存1/3，老年代占堆内存2/3。Eden区占年轻代8/10，Survivor区占年轻代2/10（其中From 和To 各站1/10)
