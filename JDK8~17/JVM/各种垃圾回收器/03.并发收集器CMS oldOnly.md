按垃圾回收线程数划分，可以分为三大类，串行垃圾回收器和并行垃圾回收器和并行垃圾回收器

- 串行回收器：Serial，Serial Old
    - 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时用户线程被暂停，直至垃圾收集工作结束。
        
- 并行回收器：ParNew，Parallel Scavenge，Parallel Old
    - 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量。
    - 不过并行回收仍然与串行回收一样，采用独占式“ Stop一the一world”，此时用户线程被暂停

如果用Seria和Parallel系列的垃圾收集器：在垃圾回收的时候，用户线程都会完全停止，直至垃圾回收结束！

- 并发回收器：CMS Old，G1
    - 并发指的是用户线程能够与gc线程并发，二者可以交替执行，以尽可能减少应用程序的停顿时间。
    - CMS （Concurrent 一Mark 一 Sweep）收集器。这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。

CMS的全称：Concurrent Mark Sweep，翻译过来是「并发标记清除」

用CMS对比上面的垃圾收集器(Seria和Parallel和parNew)：它最大的不同点就是「并发」：在GC线程工作的时候，用户线程「不会完全停止」，用户线程在「部分场景下」与GC线程一起并发执行。

但是，要理解的是，无论是什么垃圾收集器，Stop The World是一定无法避免的！CMS只是在「部分」的GC场景下可以让GC线程与用户线程并发执行。

==CMS 作为老年代的收集器==，CMS的设计目标是为了避免「老年代 GC」出现「长时间」的卡顿（Stop The World）

# CMS的工作流程如下

CMS（Concurrent Mark Sweep）整个执行过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。
![[Pasted image 20231226121301.png]]

从步骤就不难看出，CMS主要是实现了「标记清除」垃圾回收算法，标记”是指将存活的对象和要回收的对象都给标记出来，而“清除”是指清除掉将要回收的对象。

1. 初始标记
    1. 初始标记仅仅只是标记一下GC Roots能直接关联到的对象以及==被「年轻代」引用的「老年代」对象==，速度很快。
    2. 初始标记的过程是需要触发STW的，不过这个过程非常快是可控的，因此可以忽略这个过程导致的短暂停顿。
2. 并发标记【不会触发STW】
    1. 并发标记就是将初始标记的对象进行深度遍历，以这些对象为根，遍历整个对象图，这个过程耗时较长，而且标记的时间会随着堆空间的变大而变长。
    2. 不过好在这个过程是不会触发STW的，用户线程仍然可以工作，用户进程依然可以响应，只是用户进程的性能会受到一点影响。
3. 重新标记：并发标记阶段用户线程与gc线程共存，会产生漏标和错标的情况
	-  漏标：一种是原本不能被回收的对象，现在可以被回收了。
	-  错标：另一种是原本可以被回收的对象，现在不能被回收了。
	针对这两种情况，CMS需要暂停用户线程，进行一次重新标记。
4. 并发清理【不会触发STW】
    -  重新标记完成后，就可以并发清理了。这个过程耗时也比较长，且清理的开销会随着堆空间的变大而变大。
    -  不过好在这个过程也是不需要STW的，用户线程依然可以正常运行，用户程序不会卡顿，不过和并发标记一样，并发清理时GC线程依然要占用一定的CPU和系统资源，会导致程序的性能降低。

>**有人会觉得既然Mark Sweep（标记清除）会造成内存碎片，那么为什么不把算法换成Mark Compact（标记整理）呢？** 
>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？
	>要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。
	>Mark Compact更适合“Stop the World”这种场景”下使用

# 三色标记法

并发标记阶段用户线程与gc线程共存，会产生漏标和错标的情况，这也是需要第三个阶段来”重新标记”的原因


因此CMS在「可达性分析」的基础上引入了三色算法，将对象标记为黑、灰、白三种颜色的对象
- 黑色节点不能被回收，黑色对象本身及其所有的引用都被扫描过，第一次遍历==根root最终被标记为黑色==，且引用对象标记为灰色
- 灰色节点不能被回收，灰色对象本身被扫描过，但还存在至少一个引用没有被扫描，因此灰色节点又叫做临时节点，灰色区域需要进行最终扫描并标记为黑色区域。
- 白色节点可以被回收，表示没有遍历到的区域，可以理解为没有标记

CMS在每次进行标记的时候。从根root广度优先遍历，标记结束时，黑色对象存活，白色对象（未标记）的认为是垃圾并且进行清理回收。

## 漏标(浮动垃圾)问题与解决
假设用户线程执行了以下操作，意味着B、D、E都可以被回收了

```Java
A.B=null//用户线程执行了A.B=null的操作，切断了A到B的引用。
```
但是此时GC正好遍历到对象B，遍历到B意味着B不可回收，此时B变为灰色

最终的结果就是本轮GC不会回收B、D、E，漏标了
![[Pasted image 20231226132910.png]]

实际上，这个问题可以通过「写屏障」来解决

1. 只要在A写B的时候加入写屏障，记录下当前的引用关系，即B被切断的记录
2. 重新标记时可以再把B标为白色即可

## 错标问题与解决

假设用户线程执行了以下操作：
```Java
B.D=null;//灰色对象B到白色对象D的引用被切断
A.xx=D;//且黑色对象A到白色对象D的引用被建立，企图对白色对象D更新为灰色不可回收
```
此时GC线程继续工作，但是因为A是黑色节点，GC不会再遍历A了(黑色节点本身不会被遍历第二次)，所以D不会被A标记为灰色，D依然是白色，最后D被当做垃圾回收。

错标的结果是把不该回收的对象回收掉了将会造成程序运行错误，因此错标问题比漏标问题严重的多

![[Pasted image 20231226132941.png]]

要想解决错标问题，只要打破上面两个条件的任意一个即可，解决方式仍然是添加写屏障，只不过这里细化为两种不同的叫法：
- 打破第一个条件的方式是原始快照：当扫描结束后，再以写屏障记录下来的当前灰色对象为根，按照原始快照重新扫描一次，将D扫描成了灰色
- ==打破第二个条件的方式是增量更新：等扫描结束后，再以写屏障记录下来的当前黑色对象为根，强迫黑色对象再重新往下扫描一次。相当于黑色对象一旦建立了指向白色对象的引用，该黑色节点就会变为灰色对象。==

CMS采用的方案就是第二种：增量更新
1. 当黑色指向白色的引用被建立时，通过写屏障来记录引用关系，
2. 等扫描结束后，再以写屏障记录下来的当前黑色对象为根重新扫描一次即可。


伪代码大致如下：

```Java
class A{
    private D d;
    public void setD(D d) {
        writeBarrier(d);// 插入一条写屏障
        this.d = d;//后续重新扫描
    }
    private void writeBarrier(D d){
        // 将A -> D的引用关系记录下来
    }
}
```

虽然CMS从来没有被JDK当做默认的垃圾收集器，存在很多的缺点，但是它开启了「GC并发收集」的先河，为后面的收集器提供了思路，光凭这一点，就依然值得记录下来。
# CMS提前引发FullGC的两种异常原因

不过，现在很多企业都在用G1了，那你觉得CMS有什么缺点呢？
1. 浮动垃圾引发的`Concurrent mode failure`异常：并发标记阶段，会存在漏标/浮动垃圾情况，CMS收集器无法处理浮动垃圾，可能会导致堆空间耗尽，可能出现“Concurrent Mode Failure" 异常，不得不提前触发Full GC。
2. 内存碎片引发的 `Promotion failed`异常：CMS收集器为了满足用户线程和gc线程的并发，采用了标记清除算法，标记清除算法会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。比如MinorGC时，survivor空间放不下，对象只能放入老年代，而老年代也放不下造成Full GC
# CMS参数设置

- -XX:+UseConcMarkSweepGc 手动指定使用CMS收集器执行内存回收任务。
	- ==开启该参数后会自动将-XX:+UseParNewGc打开。即： ParNew （Young区用） +CMS （Old区用）的组合。==
    
- -XX：CMSinitiatingOccupanyFraction设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68号时，会执行一 次CMS 回收。 JDK6及以上版本默认值为92号
    - 如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。
    - 反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。
        
- -XX： +UseCMSCompactAtFullCollection用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。
    
- ==-XX：CMSFullGCsBeforeCompaction设置在执行多少次Full GC后对内存空间进行压缩整理。==
    
- -XX：ParallelCMSThreads 设置CMS的线程数量。
    
    - CMS 默认启动的并发线程数是（ParallelGCThreads+3） /4， ParallelGCThreads是年轻代并行收集器的线程数。
        

### **附带：**

CPU总核数 = 物理CPU个数 * 每颗物理CPU的核数

总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数

```Shell
 查看CPU信息（型号）[root@AAA ~]# cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
          28  Intel(R) Xeon(R) CPU E5-2650 v2 @ 2.60GHz 
 查看物理CPU个数 [root@AAA ~]# cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
          1
 查看每个物理CPU中core的个数(即核数) [root@AAA ~]# cat /proc/cpuinfo| grep "cpu cores"| uniq
          cpu cores : 14
 查看逻辑CPU的个数 [root@AAA ~]# cat /proc/cpuinfo| grep "processor"| wc -l
         12
```