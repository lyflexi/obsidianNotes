按垃圾回收线程数划分，可以分为三大类，串行垃圾回收器和并行垃圾回收器和并行垃圾回收器

- 串行回收器：Serial，Serial Old
    - 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时用户线程被暂停，直至垃圾收集工作结束。
- 并行回收器：ParNew，Parallel Scavenge，Parallel Old
    - 并行仅仅体现在可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量。
    - 不过并行回收仍然与串行回收一样，采用独占式“ Stop一the一world”，此时用户线程被暂停

因此，如果用Seria和Parallel系列的垃圾收集器：在垃圾回收的时候，用户线程都会完全停止，直至垃圾回收结束！

- 并发回收器：CMS Old，G1
    - 并发指的是用户线程能够与gc线程并发，二者可以交替执行，以尽可能减少应用程序的停顿时间。
    - CMS （Concurrent 一Mark 一 Sweep）收集器。这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。

CMS的全称：Concurrent Mark Sweep，翻译过来是「并发标记清除」

用CMS对比上面的垃圾收集器(Seria和Parallel和parNew)：它最大的不同点就是「并发」：在GC线程工作的时候，用户线程「不会完全停止」，用户线程在「部分场景下」与GC线程一起并发执行。

但是，要理解的是，无论是什么垃圾收集器，Stop The World是一定无法避免的！CMS只是在「部分」的GC场景下可以让GC线程与用户线程并发执行。

==CMS 作为老年代的收集器==，CMS的设计目标是为了避免「老年代 GC」出现「长时间」的卡顿（Stop The World）

# CMS的工作流程如下

CMS（Concurrent Mark Sweep）整个执行过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。
![[Pasted image 20231226121301.png]]

从步骤就不难看出，CMS主要是实现了「标记清除」垃圾回收算法，标记”是指将存活的对象和要回收的对象都给标记出来，而“清除”是指清除掉将要回收的对象。

1. 初始标记，初始标记仅仅只是标记一下GC Roots能直接关联到的对象以及被「年轻代」引用的「老年代」对象，速度很快。初始标记的过程是需要触发STW的，不过这个过程非常快是可控的，因此可以忽略这个过程导致的短暂停顿。
2. 并发标记【不会触发STW】
    1. 并发标记就是将初始标记的对象进行深度遍历，以这些对象为根，遍历整个对象图，这个过程耗时较长，而且标记的时间会随着堆空间的变大而变长。
    2. 不过好在这个过程是不会触发STW的，用户线程仍然可以工作，用户进程依然可以响应，只是用户进程的性能会受到一点影响。
3. 重新标记：并发标记阶段用户线程与gc线程共存，会产生漏标和错标的情况
	-  漏标：一种是原本不能被回收的对象，用户线程说可以被回收了，但是gc没有回收。
	-  错标：另一种是原本可以被回收的对象，用户线程说现在不能被回收了，但是gc偏偏又回收了。
	针对这两种情况，CMS需要暂停用户线程，进行一次重新标记。
4. 并发清理【不会触发STW】，这个过程耗时也比较长，且清理的开销会随着堆空间的变大而变大。不过好在这个过程也是不需要STW的，用户线程依然可以正常运行，用户程序不会卡顿，不过和并发标记一样，并发清理时GC线程依然要占用一定的CPU和系统资源，会导致程序的性能降低。

**有人会觉得既然Mark Sweep（标记清除）会造成内存碎片，那么为什么不把算法换成Mark Compact（标记整理）呢？** 
答案为了支持并发清除，清除期间用户线程运行的资源不受影响能继续执行，所以不可整理内存碎片
# 三色标记法

并发标记阶段用户线程与gc线程共存，会产生漏标和错标的情况，这也是需要第三个阶段来”重新标记”的原因

因此CMS在「可达性分析」的基础上引入了三色算法，将对象标记为黑、灰、白三种颜色的对象
- 黑色节点不能被回收，黑色对象本身及其所有的引用都被扫描过，第一次遍历根root最终被标记为黑色，且引用对象标记为灰色
- 灰色节点不能被回收，灰色对象本身被扫描过，但还存在至少一个引用没有被扫描，因此灰色节点又叫做临时节点，灰色区域需要进行最终扫描并标记为黑色区域。
- 白色节点可以被回收，表示没有遍历到的区域，可以理解为没有标记

CMS在每次进行标记的时候。从根root广度优先遍历，标记结束时，黑色对象存活，白色对象（未标记）的认为是垃圾并且进行清理回收。

## 漏标(浮动垃圾)问题与解决 ABC举例
假设用户线程执行了以下操作，意味着B、C都可以被回收了
```Java
aTob=null//用户线程执行了A.B=null的操作，切断了A到B的引用。
```
但是此时GC正好遍历到对象B，遍历到B意味着B不可回收，此时B变为灰色
![[Pasted image 20240319171736.png]]
最终的结果就是本轮GC不会回收B和C漏标了，不过漏标问题可以通过「写屏障」来解决

1. 只要在A写B的时候加入写屏障，记录下当前的引用关系，即B被切断的记录
2. 重新标记时可以再把B标为白色即可

## 错标问题与解决 ABC举例

假设用户线程执行了以下操作：
```Java
bToc=null;//灰色对象B到白色对象C的引用被切断
tToc=C;//且黑色对象A到白色对象C的引用被建立，企图对白色对象C更新为灰色不可回收
```
此时GC线程继续工作，但是因为A是黑色节点，GC不会再遍历A了(黑色节点本身不会被遍历第二次)，所以C不会被A标记为灰色，C依然是白色，最后C被当做垃圾回收。
![[Pasted image 20240319172157.png]]
错标的结果是把不该回收的对象回收掉了将会造成程序运行错误，因此错标问题比漏标问题严重的多
要想解决错标问题也是使用写屏障，又叫增量更新Incremental Update
1. 当黑色指向白色的引用被建立时，通过写屏障来记录引用关系，
2. 黑色对象一旦建立了指向白色对象的引用，该黑色节点A就会变为灰色对象，再以写屏障记录下来的当前A对象为根，强迫A节点重新往下扫描一次即可。
![[Pasted image 20240319172133.png]]
伪代码大致如下：
```Java
class A{
    private C c;
    public void setD(C c) {
        writeBarrier(c);// 插入一条写屏障
        this.c = c;//后续重新扫描
    }
    private void writeBarrier(C c){
        // 将A -> c的引用关系记录下来
    }
}
```


虽然CMS从来没有被JDK当做默认的垃圾收集器，存在很多的缺点，但是它开启了「GC并发收集」的先河，为后面的收集器提供了思路，光凭这一点，就依然值得记录下来。
# CMS提前引发FullGC的两种异常原因

不过，现在很多企业都在用G1了，那你觉得CMS有什么缺点呢？
1. 浮动垃圾引发的Concurrent mode failure异常：并发标记阶段，会存在漏标/浮动垃圾情况，CMS收集器无法处理浮动垃圾，可能会导致堆空间耗尽，不得不提前触发Full GC。
2. 内存碎片引发的 Promotion failed异常：CMS收集器为了满足用户线程和gc线程的并发，采用了标记清除算法，标记清除算法会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。比如MinorGC时，survivor空间放不下，对象只能放入老年代，而老年代也放不下造成Full GC
# CMS参数设置-重要！

- -XX:+UseConcMarkSweepGc 手动指定使用CMS收集器执行内存回收任务。开启该参数后会自动将-XX:+UseParNewGc打开。即： ParNew （Young区用） +CMS （Old区用）的组合。
- -XX：CMSinitiatingOccupanyFraction设置堆内存使用率的阈值，一旦达到该阈值，便开始进行CMS回收。JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一 次CMS 回收。 JDK6及以上版本默认值为92%
- -XX： +UseCMSCompactAtFullCollection，用于强制每次在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。
- -XX：CMSFullGCsBeforeCompaction设置在执行多少次Full GC后对内存空间进行压缩整理。
- -XX：ParallelCMSThreads 设置CMS的gc线程数量。CMS 默认启动的并发线程数是（ParallelGCThreads+3） /4， ParallelGCThreads是年轻代并行收集器的线程数。注意ParallelCMSThreads不等于ParallelGCThreads