这次来聊聊G1垃圾收集器，7款经典的垃圾收集器与垃圾分代之间的关系：
- 新生代收集器： Serial、 ParNeW、Parallel Scavenge；
- 老年代收集器： Serial Old、 Parallel Old、 CMS；
- 整堆收集器： G1是JDK 9以后的默认垃圾回收器，CMS已经在JDK 9中被标记为废弃（deprecated）
![[Pasted image 20231226140006.png]]

在G1垃圾收集器的世界上，G1将堆空间分为若干个区域（Region），这些区域逻辑包含年轻代和老年代，但是从整个堆的物理结构上看G1不要求整个Eden区、Survivor区和Old区是连续的，也不再坚持固定的比例大小。

此外在G1中，还有一种叫 Humongous（大对象）区域，其实就是用来存储特别大的对象，如果超过1. 5个region，就放到H，如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。
![[Pasted image 20231226140205.png]]
# 为什么G1使用Region
G1收集器可以理解为在CMS垃圾收集器上进行”升级”，在过去CMS的停顿时间是「不可预知的」，而G1 垃圾收集器可以给你设定一个你希望Stop The Word 停顿时间，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。即可允许的收集时间。

其实稍微想一下，也能理解为什么要将「整个堆空间」进行「逻辑细分」成不同的Region

==以前的垃圾收集器都是对堆进行「物理」划分（整个Eden区、Survivor区和Old区是连续的，且分区大小和数量是固定的），如果堆空间（内存）大的时候，每次进行「垃圾回收」都需要对一整块大的区域进行回收，那收集的时间是不好控制的。而G1将堆空间划分为一个个小Regin之后，那对这些「小区域」回收就容易限制gc的「收集时间」了，避免长时间的STW，这才是G1的根本初衷==


在G1收集器中，可以主要分为有Minor GC(Young GC)和Mixed GC，也有些特殊场景可能会发生Full GC
# Minor GC-CSet
G1的Minor GC其实触发时机跟其他垃圾收集器都是一样的，等到Eden区满了之后，会触发Minor GC。Minor GC同样也是会发生Stop The World的。但是要补充说明的是在G1的世界里，新生代和老年代所占整个堆的空间比例是没那么固定的，这个比例会动态根据「最大停顿时间」进行调整，所以，动态地改变年轻代Region的个数可以「控制」Minor GC的开销。这块要知道会给我们提供提供可停顿时间参数供用户设置（G1会尽量满足该停顿时间来调整 GC时回收Region的数量）

Collection Set保存了一次Minor中将执行垃圾回收但不一定的Region集合，简称CSet。
回收的时候CSet中的所有存活对象都会被转移到别的可用Region上
- 空的Survivor区
- 或者空的老年代
![[Pasted image 20231226140805.png]]

在Minor GC 的最后，会处理下软引用、弱引用、JNI Weak等引用，结束收集

# Minor GC如何避免全堆扫描-RSet
我们知道，传统Minor GC有两种方式来避免全全堆扫描，分别是：
- 物理地址隔离，MinorGC对老年代不感兴趣
- 通过卡表，快速检索出被老年代跨代引用的新生代对象（该类新生代对象不能被执行Minor GC）。

但是G1的堆空间是不连续的，因此G1的Minor GC只有通过第二种方式来避免全全堆扫描。==而G1解决「跨代引用」的问题的存储一般叫做RSet==

要记住，RSet这种存储在每个Region都会有，它记录着「其他Region引用了当前Region的对象关系」
- 对于年轻代的Region，它的RSet 只保存了来自老年代的引用（老不死的缠着我）
- 而对于老年代的 Region 来说，它的 RSet 也只会保存老年代对它的引用（在G1垃圾收集器，老年代回收之前，都会先对年轻代进行回收，所以没必要保存年轻代对老年代的引用关系）
![[Pasted image 20231226140548.png]]
==因此Minor GC，无非就是依据年轻代Region当中的RSet的信息，将来自老年代的跨代引用都加入到GC Roots下，避免此类年轻代Region被回收掉==

# Mixed GC全局并发标记
Mixed GC它一定会回收年轻代，并会采集部分老年代的Region进行回收的，所以它是一个“混合”GC
- G1从整体上来看是 标记-整理 算法
- 从局部（两个Region之间）是复制算法
Mixed GC 依赖「全局并发标记阶段」统计后的Region数据，当堆空间的占用率达到一定阈值后会触发Mixed GC（默认45%，由参数决定）

Mixed GC它的过程跟CMS非常类似，步骤大概是：初始标记（STW）、并发标记、重新标记（STW）以及清理（STW）
![[Pasted image 20231226141053.png]]
Mixed GC与CMS GC各阶段的对比如下，二者区别体现在后两个阶段
1. 「初始标记」差不多
2. 「并发标记」差不多
3. 「重新标记」：G1解决「并发标记」中的错标问题使用的是SATB快照算法。可以简单理解为：在GC 开始的时候，它为存活的对象做了一次「快照」。然后在「重新标记」阶段只扫描着块「发生过变化」的引用，看有没有对象还是存活的，加入到「GC Roots」上，这显然比CMS的增量更新策略快得多因为增量更新还需要再次遍历。
	- 不过SATB算法是一个保守策略，如果在开始时G1就认为它是活的不可回收，那么即便在「并发标记」阶段对象已经变为了垃圾也无法回收。因此G1的「漏标/浮动垃圾」问题无法解决
	 ![[Pasted image 20240319173302.png]]
4. 「独占清理」：回收整个 young region ，还会回收一部分的 old region 。注意：是一部分老年代，而不是全部老年代，可以选择哪些 old region 进行收集，从而可以对垃圾回收的耗时时间进行控制。
    - CMS在清理阶段使用的是并发清除算法，因此会产生内存碎片
    - ==G1从全堆收集整体上来看是 标记-整理 算法，但从局部来看（两个Region之间）是复制算法。所以G1不会产生内存碎片，但与此同时不支持并发清理==
# G1降级

G1 没有 fullGC 概念，如果在Mixed GC中无法跟上用户线程分配内存的速度，导致老年代填满无法继续进行Mixed GC，就又会降级到serial old GC来收集整个GC heap


