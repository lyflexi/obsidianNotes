这次来聊聊G1垃圾收集器，7款经典的垃圾收集器与垃圾分代之间的关系：

- 新生代收集器： Serial、 ParNeW、Parallel Scavenge；
    
- 老年代收集器： Serial Old、 Parallel Old、 CMS；
    
- 整堆收集器： G1是JDK 9以后的默认垃圾回收器，CMS已经在JDK 9中被标记为废弃（deprecated）
    
![[Pasted image 20231226140006.png]]

在G1垃圾收集器的世界上，G1将堆空间分为若干个区域（Region），==这些区域逻辑包含年轻代和老年代，但是从整个堆的物理结构上看G1不要求整个Eden区、Survivor区和Old区是连续的，也不再坚持固定的比例大小。==

此外在G1中，还有一种叫 Humongous（大对象）区域，其实就是用来存储特别大的对象，如果超过1. 5个region，就放到H，如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。
![[Pasted image 20231226140205.png]]
# 为什么G1要划分Region
G1收集器可以理解为在CMS垃圾收集器上进行”升级”，在过去CMS的停顿时间是「不可预知的」，而G1 垃圾收集器可以给你设定一个你希望Stop The Word 停顿时间，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。即可允许的收集时间。

其实稍微想一下，也能理解为什么要将「整个堆空间」进行「逻辑细分」成不同的Region

以前的垃圾收集器都是对堆进行「物理」划分（整个Eden区、Survivor区和Old区是连续的，且分区大小和数量是固定的），如果堆空间（内存）大的时候，每次进行「垃圾回收」都需要对一整块大的区域进行回收，那收集的时间是不好控制的。==而G1将堆空间划分为一个个小Regin之后，那对这些「小区域」回收就容易限制gc的「收集时间」了，避免长时间的STW，这才是G1的根本初衷==


# G1收集器的执行过程

在G1收集器中，可以主要分为有Minor GC(Young GC)和Mixed GC，也有些特殊场景可能会发生Full GC

## G1的Minor GC如何避免全堆扫描
G1的Minor GC其实触发时机跟其他垃圾收集器都是一样的，等到Eden区满了之后，会触发Minor GC。Minor GC同样也是会发生Stop The World的。但是要补充说明的是在G1的世界里，新生代和老年代所占整个堆的空间比例是没那么固定的，这个比例会动态根据「最大停顿时间」进行调整，所以，动态地改变年轻代Region的个数可以「控制」Minor GC的开销。

这块要知道会给我们提供提供可停顿时间参数供用户设置（G1会尽量满足该停顿时间来调整 GC时回收Region的数量）

Minor GC我认为可以简单分为为三个步骤：根扫描、处理跨代引用 RSet、复制对象CSet
第一步根扫描：应该很好理解，因为这跟之前CMS是类似的，可以理解为初始标记的过程
![[Pasted image 20231226140500.png]]
第二步处理跨代引用 RSet：涉及到「Rset」的概念
我们知道，传统Minor GC有两种方式来避免全全堆扫描，分别是：
- 物理地址隔离，MinorGC对老年代不感兴趣
- 通过卡表，快速检索出被老年代跨代引用的新生代对象（该类新生代对象不能被执行Minor GC）。
但是G1的堆空间是不连续的，因此G1的Minor GC只有通过第二种方式来避免全全堆扫描。==而G1解决「跨代引用」的问题的存储一般叫做RSet==

要记住，RSet这种存储在每个Region都会有，它记录着「其他Region引用了当前Region的对象关系」
- 对于年轻代的Region，它的RSet 只保存了来自老年代的引用（老不死的缠着我）
- 而对于老年代的 Region 来说，它的 RSet 也只会保存老年代对它的引用（在G1垃圾收集器，老年代回收之前，都会先对年轻代进行回收，所以没必要保存年轻代对老年代的引用关系）
![[Pasted image 20231226140548.png]]
==因此Minor GC，无非就是依据年轻代Region当中的RSet的信息，将来自老年代的跨代引用都加入到GC Roots下，避免此类年轻代Region被回收掉==


第三步复制对象：需要使用到 CSet
CSet的全称是 Collection Set，保存了一次GC中「将执行垃圾回收但不一定」的Region集合。CSet中的所有存活对象都会被转移到别的可用Region上（空的Survivor区或者空的老年代存放）
![[Pasted image 20231226140805.png]]

在Minor GC 的最后，会处理下软引用、弱引用、JNI Weak等引用，结束收集

## Mixed GC全局并发标记
Mixed GC它一定会回收年轻代，并会采集部分老年代的Region进行回收的，所以它是一个“混合”GC

Mixed GC 依赖「全局并发标记阶段」统计后的Region数据，当堆空间的占用率达到一定阈值后会触发Mixed GC（默认45%，由参数决定）

Mixed GC它的过程跟CMS非常类似，步骤大概是：初始标记（STW）、并发标记、重新标记（STW）以及清理（STW）
![[Pasted image 20231226141053.png]]
Mixed GC与CMS GC各阶段的对比如下：
1. 「初始标记」差不多
2. 「并发标记」差不多
3. 「重新标记」：
	-  CMS在「重新标记」阶段，应该会以所有的线程栈和整个年轻代作为root进行三色扫描来解决并发标记阶段的引用变更问题（漏标和错标）
	- ==G1中解决「并发标记」阶段导致引用变更的问题使用的是SATB算法。==可以简单理解为：在GC 开始的时候，它为存活的对象做了一次「快照」。然后在「重新标记」阶段只扫描着块「发生过变化」的引用（与快照不一致的引用），看有没有对象还是存活的，加入到「GC Roots」上，这显然比CMS要快得多。不过SATB算法是一个保守策略，如果在开始时G1就认为它是活的不可回收，那么即便在「并发标记」阶段对象已经变为了垃圾也无法回收。所以，G1仍然存在「漏标/浮动垃圾」的问题
        ![[Pasted image 20231226141419.png]]
4. 「独占清理」：回收整个 young region ，还会回收一部分的 old region 。注意：是一部分老年代，而不是全部老年代，可以选择哪些 old region 进行收集，从而可以对垃圾回收的耗时时间进行控制。
    - CMS在清理阶段使用的是并发清除算法，因此会产生内存碎片
    - G1垃圾回收器针对的是分regin的堆结构，这种情况下再使用标记清除算法会产生更多的内存碎片，==所以G1干脆采取的是标记整理算法避免了内存碎片的产生==，但与此同时不支持并发清理
    - G1对年轻代的清除自然是复制算法，因为Survivor区依然存在
# G1降级

G1 没有 fullGC 概念，如果在Mixed GC中无法跟上用户线程分配内存的速度，导致老年代填满无法继续进行Mixed GC，就又会降级到serial old GC来收集整个GC heap


