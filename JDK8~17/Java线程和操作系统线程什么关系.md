阿里面试官问我Java线程和操作系统线程什么关系，分三块讲
- 用户态的线程
- 内核态的线程
- Java 线程源码
# 用户态的线程
第一阶段:
其实早期的时候，操作系统是没有线程的概念，线程是后面加进来的，操作系统刚开始只有进程，操作系统分配资源的最小单位是进程，进程与进程之间相互隔离，每个进程有自己的内存空间，文件描述符，CPU调度以进程作为最小调度单元；

第二阶段:
初期的多线程，线程是在用户空间下实现的。
什么意思？ 我们都知道内存分用户空间和系统空间，系统空间是给操作系统使用的，用户空间是应用程序使用的，应用程序如果需要访问系统空间，需要进行系统调用，从用户态切换到内核态。那怎么在用户空间实现的多线程呢？

实际上是操作系统按进程维度来调度，操作系统是不去管你用户线程的切换的，应用程序自己在用户空间实现线程的创建、维护和调度。模型如下图
![[Pasted image 20240319161602.png]]


这种方式的好处之一就是即使操作系统不支持线程，用户也可以通过库函数来支持线程。在JDK1.1中，就用的绿色线程，而不是原始线程。
green threads 是一种由运行环境或虚拟机(VM)调度，而不是由本地底层操作系统调度的线程。绿色线程并不依赖底层的系统功能，模拟实现了多线程的运行，这种线程的管理调配发生在用户空间而不是内核空间，所以它们可以在没有原生线程支持的环境中工作。
在Java 1.1中，绿色线程（至少在 Solaris 上）是JVM 中使用的唯一一种线程模型。 由于绿色线程和原生线程比起来在使用时有一些限制，随后的 Java 版本中放弃了绿色线程，转而使用native threads。

这种模式的优点和缺点都非常明显:
- 缺点: 因为操作系统不知道线程的存在，CPU的时间片切换是以进程为维度的，如果进程中有某个线程进行了某些耗时长的操作，会阻塞整个进程。另外当一个进程中的某一个线程(绿色线程)进行系统调用时，比如网络IO、缺页中断等操作而导致线程阻塞，操作系统也会阻塞整个进程，即使这个进程中其它线程还在工作。
- 优点: 使用库函数来实现的线程切换，就免去了用户态到内核态的切换，这个味道熟不熟，对了，Go的协程就有借鉴了一部分这个思想。

# 内核态的线程
在 Java1.2 之后. Linux中的JVM是基于pthread实现的, 可以直接说 Java 线程就是依赖操作系统的线程实现的，是1:1的关系。
![[Pasted image 20240319162056.png]]

# 协程
线程有自己的独立的上下文，包括线程的ID、栈、程序计数器、通用的寄存器等的合集，这些由操作系统调度，由此线程消耗资源太大了，例如在linux上，一个线程默认的栈大小是1M，单机创建几万个线程就有点吃力了。所以后来在编程语言的层面上，就出现了协程这个东西。

协程的模式有点类似结合了上面二种方式，既在用户态做线程资源切换，也让操作系统在内核层做线程调度。协程跟操作系统的线程是有映射关系的，例如我们建了m个协程，需要在N个线程上执行，这就是m: n的方案，这n个线程也是靠操作系统调度实现。
- 协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程。
- 协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。
- 协程是按需使用栈内存的，所以理论上可以轻轻松松创建百万级的协程。

目前协程这块支持的最好的是go语言, 不过现在OpenJDK社区也正在为JDK增加协程的支持。