阿里面试官问我Java线程和操作系统线程什么关系，我答：进程是资源分配的单位，线程是调度和执行的单位，
光说上面这句话面试立马就寄，所以下面展开讲讲
- 进程
- 用户态的线程
- 内核态的线程
- 协程简介
# 早期无线程概念-远古
第一阶段（早期阶段）:
- 其实早期的时候，操作系统只有进程，线程的概念还没出现，线程是后面加进来的
- 进程与进程之间相互隔离，每个进程有自己的内存空间，文件描述符，CPU调度以进程作为最小调度单元；
# 用户态的线程-曾经
第二阶段（绿色线程）:
- 初期的多线程，线程是在用户空间下实现的。操作系统按进程维度来调度，操作系统是不去管你用户线程的切换的，应用程序自己在用户空间实现线程的创建、维护和调度。
- 在JDK1.1中用户空间下的线程就叫做绿色线程，而不是原始线程。green threads 是一种由运行环境或虚拟机(VM)调度，而不是由本地底层操作系统调度的线程，这种线程的管理调配发生在用户空间而不是内核空间，所以它们可以在没有原生线程支持的环境中工作。
- 即使操作系统不支持线程，用户也可以通过库函数来支持线程，就免去了用户态到内核态的切换，这个味道熟不熟，对了，Go的协程就有借鉴了一部分这个思想。
![[Pasted image 20240319161602.png]]
但是，因为操作系统不知道线程的存在，CPU的时间片切换是以进程为维度的，如果进程中有某个线程进行了某些耗时长的操作（绿色线程可以执行网络IO、缺页中断等系统调用操作从而导致阻塞），会阻塞整个进程，即使这个进程中其它线程还在工作。

所以随后的 Java 版本中放弃了绿色线程，转而使用native threads。
# 内核态的线程-当今
在 Java1.2 之后. Linux中的JVM是基于pthread实现的, 可以直接说 Java 线程就是依赖操作系统的线程实现的，是1:1的关系。
这个时候，应用程序如果需要使用线程，必须申请内核态的线程资源，这就是系统调用，发生了用户态与内核态之间的切换。
![[Pasted image 20240319162056.png]]

# 协程
线程有自己的独立的上下文，包括线程的ID、栈、程序计数器、通用的寄存器等的合集，当线程发生上下文切换的时候，其上下文需要由操作系统调度，由此线程消耗资源太大了，例如在linux上，一个线程默认的栈大小是1M，单机创建几万个线程就有点吃力了。所以后来在编程语言的层面上，就出现了协程这个东西。

协程诞生的思想，有点类似结合了上面二种方式：
- 既在用户态做线程资源切换
- 也让操作系统在内核层做线程调度。
协程跟操作系统的线程是有映射关系的，例如我们建了m个协程，需要在N个线程上执行，这就是m: n的方案，这n个线程也是靠操作系统调度实现，特点如下：
- 协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。
- 协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程。
- 协程是按需使用栈内存的，所以理论上可以轻轻松松创建百万级的协程。

所以协程被称为轻量级线程，目前协程这块支持的最好的是go语言, 不过现在OpenJDK社区也正在为JDK增加协程的支持。