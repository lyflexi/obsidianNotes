> 前言 java的一次io操作需要操作系统内核提供支持，select，poll和epoll其实都是操作系统中实现IO多路复用的方法。

涉及到的数据结构是文件描述符集合fd_set（file descriptor set），它是bitmap的数据结构。举例讲解bitmap的优势
在大部分编程语言里面，int类型一般的都是占4个byte，也是32位，甭管你这个数字是1 或者是 21亿你都得占32位，所以如果你现在有10亿个数字需要存放在内存里面，需要多少内存呢？1000000000 * 4 / 1024 / 1024 = 3800MB，大概需要3800MB内存！

为了解决这个问题，bitmap采用了一种映射机制，举个例子，假如有 1，3， 7，2，5 这5个整形数字需要存放，正常情况下你需要`5*4=20byte`，但bitmap只需要`1byte`，它是咋做到呢？
```shell
#假设下面是1byte，首先将所有位置为0，
`0 0 0 0 0 0 0 0`
#然后从第一个0开始数数，把对应数字的位置置为1，比如说第一个1那就是第2个位置置为1，第二个3就是把第4个位置置为1，依此类推...
`1 => 0 1 0 0 0 0 0 0 `
`3 => 0 0 0 1 0 0 0 0 `
`7 => 0 0 0 0 0 0 0 1 `
`2 => 0 0 1 0 0 0 0 0 `
`5 => 0 0 0 0 0 1 0 0`
#叠加起来最终的串就是0 1 1 1 0 1 0 1，等价于 1 2 3 5 7，不仅仅排序了并且能够做到快速查询，而且节省了内存！
`0 1 1 1 0 1 0 1`
```

如果按照这种转换机制，1个int类型，32位的话，可以表示0-31之间的数字！如果你要表示1万个数，就可以用数组去模拟。举个例子：一个整型是32位，也就说我们大概仅需要314个整形元素即可表示这个串，`32*314=10048`
```shell
数组第1个元素 00 - 31
数组第2个元素 32 - 63
数组第3个元素 64 - 95
数组第4个元素 96 - 127
... ...
```
提到这个算法的好处，bitmap还有一个比较好听的应用 Bloom Filter(布隆过滤器)

# select

select中这个fd数组有长度限制，在32位系统中，最大值为1024个，而在64位系统中，最大值为2048个，这个配置可以调用`/proc/sys/fs/file-max`来查看
```Shell
cat /proc/sys/fs/file-max
```
select执行流程如下：select方法被调用，首先需要将fd_set从用户空间拷贝到内核空间，然后内核查询一个或多个文件描述符的读写状态，直到有一个fd活跃，或者超时了，方法返回。
```Shell
int select(int maxfdpl, fd_set readfds, fd_set writefds, fd_set exceptfds, struct timeval timeout);
```
- 如果返回值为-1，表明发生了错误
- 如果返回值为0，表明超时了
- 如果返回值为正数，表明有n个fd准备就绪了
select方法返回后，会把整个fd_set返回给客户端（复制到用户空间）。这样一套下来，select方法的缺点就很明显了：
1. fd_set在用户空间和内核空间的频繁复制，效率低
2. 单个进程可监控的fd数量有限制，无论是1024还是2048，对于很多情景来说都是不够用的。
3. 用户线程需要轮询/遍历整个fd_set，以找出发生了IO事件的fd，效率低下
# poll-链表结构

poll本质上和select没有区别，依然需要进行数据结构的复制，依然是基于轮询来实现。

但区别就是，select使用的是fd数组，而poll则是维护了一个链表，所以从理论上，poll方法中，单个进程能监听的fd不再有数量限制。但是select存在的轮询和复制问题，poll依然存在
```Shell
int poll(struct pollfd fdarray[],nfds_t nfds,int timeout);
```

# epoll-内核级回调

`epoll` 是在Linux2.6内核正式提出，完善了select的一些缺点。
首先`epoll` 不存在最大连接数的限制，远远比1024或者2048要大，江湖传言1G的内存上能监听10W个端口
最重要的是它定义了就绪事件结构体`epoll_event`来处理，基于事件驱动来实现的，使用了内核文件级别的回调机制，不会随着fd数量上升而效率下降，当fd对应的设备发生IO事件时，内核执行回调函数epoll_ctr将该fd放到一个就绪链表中，然后由客户端epoll_wait从该链表中取出一个个fd

epoll操作实际上对应着有三个函数：epoll_create，epoll_ctr，epoll_wait

1. epoll_create相当于在内核中创建一颗红黑树，便于高效的管理注册的fd节点
2. 当需要添加一个新的fd时，会调用epoll_ctr(epoll_controll)给这个fd节点注册一个回调函数。当该fd对应的设备活跃时，会执行该fd上的回调函数，将该结点存放在一个就绪链表中，就绪链表则负责快速提供已就绪的事件。==避免了在内核空间和用户空间之间进行来回复制整个fd_set。==
3. epoll_wait的做法也很简单，其实直接就是从就绪链表中取结点，==这解决了客户端轮询的问题，以此达到O（1）的时间复杂度==

并不是所有的情况中epoll都是最好的，比如当fd数量比较小的时候，epoll不见得就一定比select和poll好
# 水平触发和边缘触发

对于select和poll来说，其触发都是水平触发，只要这个fd还存在，对应的事件就会一直被触发，即使没有数据可读。

而epoll既支持水平触发LLT和又支持边缘触发LET，LET又称高速模式，该模式下，当被监控的fd上有可读写事件发生时，epoll_wait会通知程序去读写，就算本次读写没有读完所有数据，或者甚至没有进行处理，那么下一次调用epoll_wait时，也不会获取到该fd。系统中不会充斥着大量程序不感兴趣的fd，不感兴趣直接忽视就行，下次不会再触发

