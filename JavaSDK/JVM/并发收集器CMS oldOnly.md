按垃圾回收线程数划分，可以分为三大类，串行垃圾回收器和并行垃圾回收器和并行垃圾回收器

- 串行回收器：Serial，Serial Old
    - 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时用户线程被暂停，直至垃圾收集工作结束。
        
- 并行回收器：ParNew，Parallel Scavenge，Parallel Old
    - 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量。
    - 不过并行回收仍然与串行回收一样，采用独占式“ Stop一the一world”，此时用户线程被暂停

如果用Seria和Parallel系列的垃圾收集器：在垃圾回收的时，用户线程都会完全停止，直至垃圾回收结束！

- 并发回收器：CMS Old，G1
    - 并发指的是用户线程能够与gc线程并发，二者可以交替执行，以尽可能减少应用程序的停顿时间。
    - CMS （Concurrent 一Mark 一 Sweep）收集器。这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。
        

CMS的全称：Concurrent Mark Sweep，翻译过来是「并发标记清除」

用CMS对比上面的垃圾收集器(Seria和Parallel和parNew)：它最大的不同点就是「并发」：在GC线程工作的时候，用户线程「不会完全停止」，用户线程在「部分场景下」与GC线程一起并发执行。

但是，要理解的是，无论是什么垃圾收集器，Stop The World是一定无法避免的！CMS只是在「部分」的GC场景下可以让GC线程与用户线程并发执行。

==CMS 作为老年代的收集器==，CMS的设计目标是为了避免「老年代 GC」出现「长时间」的卡顿（Stop The World）
![[Pasted image 20231226121249.png]]

**CMS的工作流程如下：**

CMS（Concurrent Mark Sweep）整个执行过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。
![[Pasted image 20231226121301.png]]

从步骤就不难看出，CMS主要是实现了「标记清除」垃圾回收算法，标记”是指将存活的对象和要回收的对象都给标记出来，而“清除”是指清除掉将要回收的对象。

1. 初始标记
    
    1. 初始标记仅仅只是标记一下GC Roots能直接关联到的对象以及被「年轻代」引用的「老年代」对象，速度很快。
        
    2. 初始标记的过程是需要触发STW的，不过这个过程非常快，而且初始标记的耗时不会因为堆空间的变大而变慢，是可控的，因此可以忽略这个过程导致的短暂停顿。
        
2. 并发标记【不会触发STW】
    
    1. 并发标记就是将初始标记的对象进行深度遍历，以这些对象为根，遍历整个对象图，这个过程耗时较长，而且标记的时间会随着堆空间的变大而变长。
        
    2. 不过好在这个过程是不会触发STW的，用户线程仍然可以工作，用户进程依然可以响应，只是用户进程的性能会受到一点影响。
        
3. 重新标记
    
      由于并发标记时，用户线程仍在运行，这意味着并发标记期间，用户线程有可能改变了对象间的引用关系，可能会发生下面两种情况：
    
    2. 一种是原本不能被回收的对象，现在可以被回收了，这类对象指的是被新生代所引用的老年代对象。
        
    3. 另一种是原本可以被回收的对象，现在不能被回收了。针对这两种情况，CMS需要暂停用户线程，进行一次重新标记。
        
    
      不同于卡表，这种跨代与卡表的跨代正好相反！！！CMS在「重新标记」阶段，会重新扫描所有的线程栈和整个年轻代作为root**。**这两种情况需要在重新标记阶段遍历新生代来看看在「并发标记」过程中有没有年轻代对象引用了老年代而后又取消了引用，或者有没有年轻代对象一开始没有引用老年代而后又引用了。不过JVM里给我们提供了很多「参数」，有可能在这个过程中会触发一次 minor GC（触发了minor GC 是意味着就可以更少地遍历新生代的对象）
    
4. 并发清理【不会触发STW】
    
    1. 重新标记完成后，就可以并发清理了。这个过程耗时也比较长，且清理的开销会随着堆空间的变大而变大。
        
    2. 不过好在这个过程也是不需要STW的，用户线程依然可以正常运行，用户程序不会卡顿，不过和并发标记一样，并发清理时GC线程依然要占用一定的CPU和系统资源，会导致程序的性能降低。
        

为什么CMS要使用Mark Sweep（标记清除）算法？

**有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？** 答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？

- 要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。
    
- Mark Compact更适合“Stop the World”这种场景”下使用
    

# **CMS可能发生的异常**

**不过，现在很多企业都在用G1了，那你觉得CMS有什么缺点呢？**

- Promotion failed：MinorGC时，survivor空间放不下，对象只能放入老年代，而老年代也放不下造成。CMS收集器为了满足用户线程和gc线程的并发，采用了标记清除算法，标记清除算法会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。
    
- Concurrent mode failure：CMS收集器运行期间，由于CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure" 失败而导致另一次Full GC的产生。
    
    - 浮动垃圾：并发清理阶段，由于用户线程仍在运行，在此期间用户线程制造的垃圾就被称为“浮动垃圾”，浮动垃圾本次GC无法清理，只能留到下次GC时再清理。
        

# 三色标记算法

CMS为了让GC线程和用户线程一起工作，回收的算法和过程比以前旧的收集器要复杂很多。究其原因，就是因为GC标记对象的同时，用户线程还在修改对象的引用关系。

因此CMS在「可达性分析」的基础上引入了三色算法，将对象标记为黑、灰、白三种颜色的对象

- 黑色节点特征：
    
    - 对象本身及其所有的引用都被扫描过，第一次遍历根root最终被标记为黑色，且引用对象标记为灰色
        
    - 再次遍历时由于黑色区域的引用区域也已经标记，所以不会再次扫描黑色标记
        
    - 不能被回收
        
- 灰色节点特征：
    
    - 对象本身被扫描，还存在至少一个引用没有被扫描，因此灰色节点又叫做临时节点
        
    - 灰色区域需要进行扫描并最终标记为黑色区域。
        
    - 不能被回收
        
- 白色节点特征：没有遍历到的区域，可以理解为没有标记，扫描结束后白色的可以被回收
    

CMS在每次进行标记的时候。从根root广度优先遍历，标记结束时，黑色对象存活，白色对象<未标记>的认为是垃圾并且进行清理回收。

这个过程正确执行的前提是没有其他线程改变对象间的引用关系，然而，并发标记的过程中，用户线程仍在运行，因此就会产生漏标和错标的情况。

## 浮动垃圾问题与解决

假设GC已经在遍历对象B了（遍历到B意味着B不可回收），此时用户线程执行了以下操作：

```Java
A.B=null//用户线程执行了A.B=null的操作，切断了A到B的引用。
```

本来执行了A.B=null之后，B、D、E都可以被回收了，但是由于B已经变为灰色，它仍会被当做存活对象，继续遍历下去。

最终的结果就是本轮GC不会回收B、D、E，留到下次GC时回收，这就是浮动垃圾。

![](https://x3r1317gt9.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE5OWZmM2QyM2IyMTA4M2NhNmYwNjc4NGE0MDU3YjNfUXZSMmlwSTVrSkhFdGFvQnRmUUF6ME5UV0VZWWEwR2tfVG9rZW46SU1ZaGJMbmpUbzlqdld4NWJvSWNGWmE1bkVmXzE3MDM1NjM4NTg6MTcwMzU2NzQ1OF9WNA)

实际上，这个问题可以通过「写屏障」来解决

1. 只要在A写B的时候加入写屏障，记录下当前的引用关系，即B被切断的记录
    
2. 重新标记时可以再把B标为白色即可
    

## 错标问题与解决

假设GC线程已经遍历到B了（遍历到B意味着B不可回收），此时用户线程执行了以下操作：

- 灰色指向白色的引用全部断开
    
- 黑色指向白色的引用被建立
    

```Java
B.D=null;//灰色对象B到白色对象D的引用被切断
A.xx=D;//且黑色对象A到白色对象D的引用被建立
```

此时GC线程继续工作，但是因为A是黑色节点，GC不会再遍历A了，所以D不会被A标记为灰色，D依然是白色，最后D被当做垃圾回收。

可以看到错标的结果比浮动垃圾问题严重的多

- 浮动垃圾可以下次GC清理
    
- 而错标的结果是把不该回收的对象回收掉了，将会造成程序运行错误。
    

![](https://x3r1317gt9.feishu.cn/space/api/box/stream/download/asynccode/?code=ODg4YjczNTM3YWU5NDIyYWZiOTRjN2JiZjA1MmE3OGZfalN4ODh3ZUhhekQzdW1DUmk1TnphTEJjMFI2b0FPaFdfVG9rZW46RzN0NmJHajNEb3g0VHR4Z3h6bGNXSVpibkJoXzE3MDM1NjM4NTg6MTcwMzU2NzQ1OF9WNA)

要想解决错标问题，只要打破上面两个条件的任意一个即可，但是打破之前要先通过写屏障将当前这条引用关系记录下来。注意：这个写屏障指的可不是并发编程里的写屏障哦！这里的写屏障指的是属性赋值的前后加入一些处理，类似于AOP。

- 打破第一个条件：灰色对象指向白色对象的引用被断开。打破方式：原始快照。当扫描结束后，再以写屏障记录下来的当前灰色对象为根，按照原始快照重新扫描一次，将D扫描成了灰色
    
- 打破第二个条件：黑色指向白色的引用被建立。打破方式：增量更新。等扫描结束后，再以写屏障记录下来的当前黑色对象为根，强迫黑色对象再重新往下扫描一次。相当于黑色对象一旦建立了指向白色对象的引用，就会变为灰色对象。
    

CMS采用的方案就是第二种：增量更新

1. 当黑色指向白色的引用被建立时，通过写屏障来记录引用关系，
    
2. 等扫描结束后，再以写屏障记录下来的当前黑色对象为根重新扫描一次即可。
    

伪代码大致如下：

```Java
class A{
    private D d;
    public void setD(D d) {
        writeBarrier(d);// 插入一条写屏障
        this.d = d;
    }
    private void writeBarrier(D d){
        // 将A -> D的引用关系记录下来，后续重新扫描
    }
}
```

虽然CMS从来没有被JDK当做默认的垃圾收集器，存在很多的缺点，但是它开启了「GC并发收集」的先河，为后面的收集器提供了思路，光凭这一点，就依然值得记录下来。

# CMS参数设置

- `-XX:+UseConcMarkSweepGc` 手动指定使用CMS收集器执行内存回收任务。开启该参数后会自动将`-XX:+UseParNewGc`打开。即： ParNew （Young区用） +CMS （Old区用） +Serial Old的组合。
    
- -XX：CMSinitiatingOccupanyFraction设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68号时，会执行一 次CMS 回收。 JDK6及以上版本默认值为92号
    
    - ➢如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。
        
    - 反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。
        
- -XX： +UseCMSCompactAtFullCollection用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。
    
- -XX：CMSFullGCsBeforeCompaction设置在执行多少次Full GC后对内存空间进行压缩整理。
    
- -XX：ParallelCMSThreads 设置CMS的线程数量。
    
    - CMS 默认启动的并发线程数是（ParallelGCThreads+3） /4， ParallelGCThreads是年轻代并行收集器的线程数。
        

### **附带：**

CPU总核数 = 物理CPU个数 * 每颗物理CPU的核数

总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数

```Shell
 查看CPU信息（型号）[root@AAA ~]# cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
          28  Intel(R) Xeon(R) CPU E5-2650 v2 @ 2.60GHz 
 查看物理CPU个数 [root@AAA ~]# cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
          1
 查看每个物理CPU中core的个数(即核数) [root@AAA ~]# cat /proc/cpuinfo| grep "cpu cores"| uniq
          cpu cores : 14
 查看逻辑CPU的个数 [root@AAA ~]# cat /proc/cpuinfo| grep "processor"| wc -l
         12
```