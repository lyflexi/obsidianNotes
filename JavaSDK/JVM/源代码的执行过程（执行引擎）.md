今天从基础先问起吧，**你是怎么理解Java是一门「跨平台」的语言，也就是「一次编译，到处运行的」？**

很好理解啊，因为我们有JVM。Java源代码会被编译为class文件，class文件是运行在JVM之上的。JVM负责把Class字节码解释成系统所能识别的指令并执行，同时也负责程序运行时内存的管理。

**从源码文件(.java)到代码执行一共有四个阶段：**

**编译->加载->解释->执行**

# 编译阶段

编译阶段会将源码文件编译成JVM可以解释的class文件。具体过程是：

1. 「语法分析」
    
2. 「语义分析」
    
3. 「注解处理」，比如我们经常用的Lombok就是在编译阶段干的。
    
4. 最后才生成字节码文件。
    
![[Pasted image 20231226110732.png]]

# 加载阶段

加载阶段会将编译后的class文件加载到JVM中。在加载阶段又可以细化几个步骤：

装载->连接->初始化
![[Pasted image 20231226110740.png]]

## 装载

【装载时机】：为了节省内存的开销，并不会一次性把所有的class文件都装载至JVM，而是等到「有需要」的时候才进行装载（比如new和反射等等）。最后创建出对应的Class对象以及类信息，并且存储至方法区

【装载规则】：class文件是通过「类加载器」装载到jvm中的，为了防止内存中出现多份同样的字节码，使用了双亲委派机制（它不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上）。

- JDK 中的本地方法类一般由根加载器（Bootstrp loader）装载，
    
- JDK 中内部实现的扩展类一般由扩展加载器（ExtClassLoader ）实现装载，
    
- 而程序中的类文件则由系统加载器（AppClassLoader ）实现装载。
    

## 连接

「连接」这个阶段它做的事情可以总结为：对class的信息进行验证、为「类变量」分配内存空间并对其赋默认值。连接又可以细化为几个步骤：验证->准备->解析

1. 验证：验证类是否符合 Java 规范和 JVM 规范
    
2. 准备：为类的静态变量分配内存，初始化为系统的初始值
    
3. 解析：将符号引用转为直接引用的过程
    

## 初始化

「初始化」阶段阶段可以总结为：为类的静态变量赋值。过程大概就是收集class的静态变量、静态代码块、静态方法至`<client>`方法，随后从上往下开始执行。如果「实例化对象」则会调用方法对实例变量进行初始化，并执行对应的构造方法内的代码。
![[Pasted image 20231226110816.png]]

# 解释阶段

初始化完成之后，当我们尝试执行一个类的方法时，会找到对应方法的字节码的信息，然后解释器会把字节码信息解释成系统能识别的指令码。在解释阶段会有两种方式把字节码信息解释成机器指令码，

- 一个是解释器Intercepter
    
- 一个是即时编译器(JIT)

## 普通解释器intercepter

普通解释器这个阶段它做的事情可以总结为：无差别的把字节码转换为操作系统识别的指令

## 编译解释器JIT

JVM会对「热点代码」做编译，非热点代码直接进行解释。当JVM发现某个方法或代码块的运行特别频繁的时候，就有可能把这部分代码认定为「热点代码」

使用「热点探测」来检测是否为热点代码。「热点探测」一般有两种方式，计数器和抽样。HotSpot使用的是「计数器」的方式进行探测，为每个方法准备了两类计数器：==方法调用计数器和循环回边计数器==，这就是jvm执行引擎中的Profiler工具的作用了
![[Pasted image 20240130130946.png]]
循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：
```java
public void nlp(Object obj) {
  int sum = 0;
  for (int i = 0; i < 200; i++) {
    sum += i;
  }
}
```

上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。
```java
public void nlp(java.lang.Object);
    Code:
       0: iconst_0
       1: istore_1
       2: iconst_0
       3: istore_2
       4: iload_2
       5: sipush        200
       8: if_icmpge     21
      11: iload_1
      12: iload_2
      13: iadd
      14: istore_1
      15: iinc          2, 1
      18: goto          4
      21: return
```

在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。

无论是==方法调用计数器或者是循环回边计数器==都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。
即时编译器把热点方法的指令码保存起来，下次执行的时候就无需重复的进行解释，直接执行缓存的机器语言
![[Pasted image 20231226110840.png]]


# 执行阶段

「执行」这个阶段它做的事情可以总结为：操作系统把解释器解析出来的指令码，调用系统的硬件执行最终的程序指令。上面就是我对从源码文件(.java)到代码执行的过程的理解了。
![[Pasted image 20231226110847.png]]

本文总结：

- Java跨平台因为有JVM屏蔽了底层操作系统
    
- Java源码到执行的过程，从JVM的角度看可以总结为四个步骤：编译->加载->解释->执行
    
    - 「编译」经过 语法分析、语义分析、注解处理 最后才生成会class文件
        
    - 「加载」又可以细分步骤为：装载->连接->初始化。装载则把class文件装载至JVM，连接则校验class信息、分配内存空间及赋默认值，初始化则为变量赋值为正确的初始值。连接里又可以细化为：验证、准备、解析
        
    - 「解释」则是把字节码转换成操作系统可识别的执行指令，在JVM中会有字节码解释器和即时编译器。在解释时会对代码进行分析，查看是否为「热点代码」，如果为「热点代码」则触发JIT编译，下次执行时就无需重复进行解释，提高解释速度
        
    - 「执行」调用系统的硬件执行最终的程序指令