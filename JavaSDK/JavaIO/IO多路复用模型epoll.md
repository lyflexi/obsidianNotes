select，poll和epoll其实都是操作系统中IO多路复用实现的方法。

1. 从用户空间拷贝fd_set到内核空间
    
2. 从内核空间拷贝fd_set到用户空间
    

fd_set（文件描述符集合(file descriptor_set），它是bitmap的数据结构，可以简单理解为只要位为0，那说明还没数据到缓冲区，只要位为1，那说明数据已经到缓冲区。

>关于bitmap：
>在大部分编程语言里面，int类型一般的都是占4个byte，也是32位，甭管你这个数字是1 或者是 21亿你都得占32位，所以如果你现在有10亿个数字需要存放在内存里面，需要多少内存呢？1000000000 * 4 / 1024 / 1024 = 3800MB，大概需要3800MB内存！
>
>为了解决这个问题，bitmap采用了一种映射机制，举个例子，假如有 1，3， 7，2，5 这5个整形数字需要存放，正常情况下你需要`5*4=20byte`，但bitmap只需要`1byte`，它是咋做到呢？
>
>假设下面是1byte，首先将所有位置为0，从第一个0开始数数，把对应数字的位置置为1
>`0 0 0 0 0 0 0 0`
>比如说第一个1那就是第2个位置置为1，第二个3就是把第4个位置置为1，依此论推...
>`1 => 0 1 0 0 0 0 0 0 `
>`3 => 0 0 0 1 0 0 0 0 `
>`7 => 0 0 0 0 0 0 0 1 `
>`2 => 0 0 1 0 0 0 0 0 `
>`5 => 0 0 0 0 0 1 0 0`
>叠加起来最终的串就是：
>`0 1 1 1 0 1 0 1`
>结果就是 1 2 3 5 7，不仅仅排序了并且能够做到快速查询，而且节省了内存！
>
>如果按照这种转换机制，1个int类型，32位的话，可以表示0-31之间的数字！如果你要表示1万个数，就可以用数组去模拟。举个例子：一个整型是32位，也就说我们大概需要314个整形元素即可表示这个串，`32*314=10048`
>
>数组第1个元素 00 - 31
>数组第2个元素 32 - 63
>数组第3个元素 64 - 95
>数组第4个元素 96 - 127
>... ...
>
>提到这个算法的好处，bitmap还有一个比较好听的应用 Bloom Filter(布隆过滤器)

# select

select方法本质其实就是维护了一个文件描述符（fd）数组，以此为基础，实现IO多路复用的功能。这个fd数组有长度限制，在32位系统中，最大值为1024个，而在64位系统中，最大值为2048个，这个配置可以调用`/proc/sys/fs/file-max`来查看

```Shell
cat /proc/sys/fs/file-max
```

select方法被调用，首先需要将fd_set从用户空间拷贝到内核空间，然后内核用poll机制（此poll机制非IO多路复用的那个poll方法，可参加附录）直到有一个fd活跃，或者超时了，方法返回。

```Shell
int select(int maxfdpl, fd_set readfds, fd_set writefds, fd_set exceptfds, struct timeval timeout);
```

- 如果返回值为-1，表明发生了错误
    
- 如果返回值为0，表明超时了
    
- 如果返回值为正数，表明有n个fd准备就绪了
    

select方法返回后，需要轮询fd_set，以检查出发生IO事件的fd。这样一套下来，select方法的缺点就很明显了：

- fd_set在用户空间和内核空间的频繁复制，效率低
    
- 单个进程可监控的fd数量有限制，无论是1024还是2048，对于很多情景来说都是不够用的。
    
- 基于轮询来实现，效率低
    

# poll

poll本质上和select没有区别，依然需要进行数据结构的复制，依然是基于轮询来实现。

但区别就是，select使用的是fd数组，==而poll则是维护了一个链表，所以从理论上，poll方法中，单个进程能监听的fd不再有数量限制==。但是轮询，复制等select存在的问题，poll依然存在

```Shell
int poll(struct pollfd fdarray[],nfds_t nfds,int timeout);
```

# epoll

`epoll` 是在Linux2.6内核正式提出，完善了select的一些缺点。

- 首先`epoll` 不存在最大连接数的限制。
    
- 最重要的是它定义了就绪事件结构体`epoll_event`来处理，==基于事件驱动来实现的，使用了内核文件级别的回调机制==，当fd对应的设备发生IO事件时，就会调用这个回调函数，将该fd放到一个链表中，然后由客户端从该链表中取出一个个fd，以此达到O（1）的时间复杂度
![[Pasted image 20231225132608.png]]

epoll操作实际上对应着有三个函数：epoll_create，epoll_ctr，epoll_wait

## epoll_create

epoll_create相当于在内核中创建一个存放fd的数据结构。在select和poll方法中，内核都没有为fd准备存放其的数据结构，只是简单粗暴地把数组或者链表复制进来；而epoll则不一样，epoll_create会在内核建立一颗专门用来存放fd结点的红黑树，后续如果有新增的fd结点，都会注册到这个epoll红黑树上。

## epoll_ctr

另一点不一样的是，select和poll会一次性将监听的所有fd都复制到内核中，而epoll不一样，当需要添加一个新的fd时，会调用epoll_ctr，给这个fd注册一个回调函数，然后将该fd结点注册到内核中的红黑树中。

当该fd对应的设备活跃时，会调用该fd上的回调函数，将该结点存放在一个就绪链表中。这也解决了在内核空间和用户空间之间进行来回复制的问题。

## epoll_wait

epoll_wait的做法也很简单，其实直接就是从就绪链表中取结点，这也解决了轮询的问题，时间复杂度变成O(1)

所以综合来说，epoll的优点有：

- 没有最大并发连接的限制，远远比1024或者2048要大。（江湖传言1G的内存上能监听10W个端口）
    
- 效率变高。epoll是基于事件驱动实现的，不会随着fd数量上升而效率下降
    
- 减少内存拷贝的次数
    

# 水平触发和边缘触发

水平触发的意思就是说，只要条件满足，对应的事件就会一直被触发。所以如果条件满足了但未进行处理，那么就会一直被通知

边缘触发的意思就是说，条件满足后，对应的事件只会被触发一次，无论是否被处理，都只会触发一次。

而对于select和poll来说，其触发都是水平触发。而epoll则有两种模式：EPOLLLT和EPOLLET

- EPOLLLT（默认状态）：也就是水平触发。在该模式下，只要这个fd还有数据可读，那么epoll_wait函数就会返回该fd
    
- EPOLLET（高速模式）：也就是边缘触发。在该模式下，当被监控的fd上有可读写事件发生时，epoll_wait会通知程序去读写，若本次读写没有读完所有数据，或者甚至没有进行处理，那么下一次调用epoll_wait时，也不会获取到该fd。这种效率比水平触发的要高，系统中不会充斥着大量程序不感兴趣的fd，不感兴趣直接忽视就行，下次不会再触发
    

# 总结

- select，poll是基于轮询实现的，将fd_set从用户空间复制到内核空间，然后让内核空间以poll机制来进行轮询，一旦有其中一个fd对应的设备活跃了，那么就把整个fd_set返回给客户端（复制到用户空间），再由客户端来轮询每个fd的，找出发生了IO事件的fd
    
- epoll是基于事件驱动实现的，加入一个新的fd，会调用epoll_ctr函数为该fd注册一个回调函数，然后将该fd结点注册到内核中的epoll红黑树中，当IO事件发生时，就会调用回调函数，将该fd结点放到就绪链表中，epoll_wait函数实际上就是从这个就绪链表中获取这些fd。
    
- epoll分为EPOLLLT（水平触发，默认状态）和EPOLLET（边缘触发，效率高）
    
- 并不是所有的情况中epoll都是最好的，比如当fd数量比较小的时候，epoll不见得就一定比select和poll好