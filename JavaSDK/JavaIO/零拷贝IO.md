>所谓零拷贝：CPU不必在内存层面去拷贝数据，也就是说全程没有通过cpu来搬运数据，所有的数据都是由DMA来进行传输的。

早期的I/O原始过程是这样的：

CPU发出指令给磁盘控制器，然后返回；

磁盘控制器收到指令后，将数据复制到磁盘的内部缓冲区，随后对CPU发起IO中断信号

CPU收到中断信号后，将磁盘缓冲区的数据读到CPU寄存器中，CPU再将寄存器中的数据写入到内存，写入到内存期间CPU是无法执行其他任务

执行过程如图所示：
![[Pasted image 20231225132725.png]]

整个数据搬运到内存的过程中都需要CPU参与计算。如果用到千兆网卡或者磁盘传输大量数据的时候，CPU一直处于搬运复制数据的过程中，将会对系统的负载和吞吐量产生比较大的影响。

于是发明了==DMA(Direct Memory Acess)技术，也就是直接内存访问。同时为了保证内核的安全，操作系统将虚拟空间划分为「用户空间」和「内核空间」==

直接内存访问（DMA，Direct Memory Access）是一些计算机总线架构提供的功能，它能使数据从附加设备（如磁盘驱动器）直接发送到计算机主板的内存上。因此，数据从磁盘到内核缓冲区的传输过程中，CPU不再参与搬运，全都是DMA控制器完成，这样可以减轻CPU的负载。

早期DMA只存在于主板上，如今基本上每个I/O设备都有自己的DMA控制器。
![[Pasted image 20231225132747.png]]

假设用户进程是网卡，需求是从磁盘中读取数据，再写入网卡，那么完整的拷贝流程如下图：
![[Pasted image 20231225132756.png]]

用户线程调用了系统函数一次`read()`和一次`write()`，每次系统调用都要拷贝两次数据，因此两次系统调用共引发的的4次数据拷贝：

- 其中两次拷贝是由DMA完成的
    
- 两次拷贝是CPU完成的。同时用户态和内核态之间也切换了两次
    

想要提高文件传输性能，需要减少CPU对数据的拷贝次数

# sendfile()减少CPU拷贝次数

通过调用sendfile()函数替代前面的read()和write()系统调用，可以直接把内核缓冲区里面的数据拷贝到socket缓冲区，这样

- CPU的拷贝次数从两次减少为了1次
    
- 同时省去了前面两次用户态和内核态之间的切换。
    

如下图所示：
![[Pasted image 20231225132812.png]]
但此时的sendfile()仍属于cpu拷贝，仍然用到了cpu，如何能够不适用cpu拷贝呢，即所谓的零拷贝呢？

# SG-DMA网卡真正实现零拷贝

从内核2.4版本开始，如果网卡支持SG-DMA（The Scatter-Gather Direct Memory Access），可以进一步省去CPU把内核缓冲区里面的数据拷贝到socket缓冲区的过程。可以通过以下命令查看网卡是否支持scatter-gather特性：
![[Pasted image 20231225132819.png]]

于是，从内核2.4版本开始，对于网卡支持SG-DMA技术的情况下，sendfile() 系统调用过程可以实现真正的零拷贝（Zero-copy），因为我们没有在内存层面去拷贝数据，也就是说==全程没有通过cpu来搬运数据==，所有的数据都是由DMA来进行传输的。整个过程如下图所示：

![[Pasted image 20231225132826.png]]

零拷贝技术的文件传输方式相比传统文件传输的方式
- CPU的拷贝次数从两次减少为了0次
- 同时也省去了前面两次用户态和内核态之间的切换。


所以总体上看，零拷贝技术可以把文件的传输性能提高至少一倍以上。

# 目前开源的零拷贝技术

Java提供了NIO库中的`transferTo`方法

go语言中的`syscall`包中的Sendfile都提供了直接操作底层零拷贝技术的能力。

比较火热的kafka开源项目，也利用了零拷贝技术，大幅提升I/O吞吐量，这也是kafka能够处理海量数据的原因之一。

参考一些资料上的性能测试数据，同一个硬件条件下，传统文件传输和零拷贝文件传输性能差异，可以看下图的测试数据图，使用零拷贝能缩短65%的时间。
![[Pasted image 20231225132835.png]]