六大设计原则主要是指：
- 单一职责原则SRP（Single Responsibility Principle）；
- 接口隔离原则ISP（Interface Segregation Principle）；
- 里氏替换原则LSP（Liskov Substitution Principle）；
- 依赖倒置原则DIP（Dependence Inversion Principle）；
- 迪米特法则LKP（Law of Demeter），又叫“最少知道法则（The Least Knowledge Principle）”；
- 开闭原则OCP（Open Closed Principle）；

# 单一职责原则SRP

单一职责原则要求一个接口或一个类只能有一个原因引起变化，也就是一个接口或者类只能有一个职责，它就负责一件事情或者一类事情

**bad case**：IPhone类承担了协议管理（Dial、HangUp）、数据传送（Chat）。
![[Pasted image 20231225110438.png]]

**good case**：
![[Pasted image 20231225110447.png]]

# 接口隔离原则ISP

定义：接口隔离原则，客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。

假如你创建了一个程序库，它能让程序方便地与多种云计算供应商进行整合。最初版本仅支持阿里云服务，并且它覆盖了一套完整的云服务和功能。

但当你着手为其他供应商提供支持时，程序库中绝大部分的接口会显得过于宽泛。其他云服务供应商没有提供部分方法所描述的功能。
![[Pasted image 20231225110455.png]]

尽管你仍然可以去实现这些方法并放入一些桩代码，但这绝不是优良的解决方案。更好的方法是将接口拆分为多个部分。

能够实现原始接口的类现在只需改为实现多个精细的接口即可。其他类则可仅实现对自己有意义的接口。
![[Pasted image 20231225110506.png]]

>单一职责原则似乎与接口隔离原则很像，因此前两个原则饱受争议。这里进行区分
> - 单一职责原则是直接在业务方面划分，所以是站在接口的角度上观看来约束类，业务逻辑首先应该考虑大的模块，这个大的模块就应该是最顶层的抽象类或接口，所以是站在接口的角度上来看；
>- 而接口隔离原则定义说的是“一个类对另一个类的依赖”，这个定义是类与类之间的，所以接口隔离原则应该是站在类的角度上来约束接口。


所以我们定义接口时应该从两个方面来考虑：
1. 首先是业务逻辑层面，要先将业务划分好，所需要的每个模块的功能进行划分，尽量划分到一个功能模块仅有一个方法。
2. 其次我们在定义类的时候也要再次考虑接口的定义是否有冗余，是否有可以再度拆分的可能，功能可否达到更简等。

通过两个层面的考虑，我们就可以最终敲定上层接口了。

# 里式替换原则LSP

**定义**：里氏代换原则(Liskov Substitution Principle LSP)，任何基类可以出现的地方，子类一定可以出现。

**bad case**：ToyGun（玩具枪）继承了AbstractGun，但Solider在调用KillEnemy()时会报错（ToyGun无法KillEnemy/玩具枪无法杀敌），即ToyGun无法完全行使AbstractGun的职责。
![[Pasted image 20231225110824.png]]

**good case**：AbstractToy中将声音、形状都委托给AbstractGun处理。

如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用关联（聚集、组合）或者依赖关系来代替。
![[Pasted image 20231225110832.png]]

# 依赖倒置原则DIP

定义：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。

简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

**bad case**：Driver强依赖于奔驰车。
![[Pasted image 20231225110845.png]]

**good case**：
![[Pasted image 20231225110850.png]]

# 迪米特法则LKP

定义：迪米特法则（Law of Demeter）又叫作最少知识原则（The Least Knowledge Principle）

## 1.只和朋友交流

一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解，只和朋友通信，不和陌生人说话。

**bad case**：
![[Pasted image 20231225110859.png]]

**good case**：Teacher要求GroupLeader清点女生的数量，所以Teacher本身不应该依赖于Gril。
![[Pasted image 20231225110906.png]]

## 2.朋友间也是有距离的

一个类公开的public属性或方法越多，变更public成员引起的风险扩散也就越大。

所以，我们开发中尽量不要对外公布太多public方法和非静态的public变量，尽量内敛。

# 开闭原则OCP

开闭原则非常著名，只要是做面向对象编程的，在开发时都会提及开闭原则。

定义：开闭原则，在面向对象编程领域中，规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”。

你的电子商务程序中包含一个计算运输费用的订单Order类，该类中所有运输方法都以硬编码的方式实现。如果你需要添加一个新的运输方式，那就必须承担对订单类造成破

坏的可能风险来对其进行修改。
![[Pasted image 20231225110920.png]]
你可以通过应用策略模式来解决这个问题。首先将运输方法抽取到拥有同样接口的不同类中。
![[Pasted image 20231225110930.png]]
现在， 当需要实现一个新的运输方式时， 你可以通过扩展运输方式Shipping 接口来新建一个类， 无需修改任何订单类的代码。当用户在UI 中选择这种运输方式时，订单类客户端代码会将订单链接到新类的运输方式对象。

此外，根据单一职责原则，这个解决方案能够让你将运输时间的计算代码移动到与其相关度更高的类中。

所以，开闭原则是最基础的一个原则，前面介绍的5个原则都是开闭原则的具体形态，而开闭原则才是其精神领袖。