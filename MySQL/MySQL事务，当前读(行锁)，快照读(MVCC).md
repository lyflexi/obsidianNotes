要知道只有innodb存储引擎支持事务，myisam存储引擎不支持事务，事务的ACID性质全称Atomicity Consistency Isolation Durability
- 原子性： 一个事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。
- 一致性： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
- 隔离性（隔离级别）： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，从低到高依次为，读未提交`Read uncommitted`、提已交读`read committed`、可重复读`repeatable read`、串行化`Serializable`
- 持久性: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
# 并发事务带来的问题

在典型的应用程序中，多个事务有可能会并发运行，多个用户操作相同的数据来完成各自的任务。
数据库并发场景有三种，分别为：
- 读-读：不存在任何问题，也不需要并发控制
- 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
- 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失
下面挨个分析读-写，写-写会导致的问题：
1. 脏读（`读-写`）: 当一个事务正在访问数据并且对数据进行了修改，虽然数据库已被修改，但是这个修改还没有commit，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，==未提交的事务后续有可能会进行回滚==，那么依据“脏数据”所做的操作可能是不正确的。
2. 丢失修改（`写-写`）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-10，事务2也修改A=A-10，最终结果A=10，事务1的修改被丢失（事务2并没有在事务1结束之后做修改）。
3. 不可重复读（长事务）（`读-写`）: 指在长事务方法中多次读同一数据。由于第二个事务对数据进行了修改，导致长事务的多次读取数据不一样。
4. 幻读（Phantom read）（`读-写`）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

不可重复度和幻读区别：
- 不可重复读的重点是修改：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。
- 幻读的重点在于新增或者删除：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。
# 隔离级别设置

MySQL为了解决并发事务产生的问题，支持以下的隔离级别：

- RU，READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、不可重复读、幻读。
- RC，READ-COMMITTED(读取已提交)： 读取并发事务已经提交的数据，字如其名避免了丢失修改，另外还可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- RR，REPEATABLE-READ(保证可重读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。==MySQL默认隔离级别就是可重读RR==
- SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别

MySQL InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读），通过下述命令可以查看隔离级别

```Java
//MySQL8.0之前的查看命令
mysql> SELECT @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
//MySQL8.0之后的查看命令
mysql> SELECT @@transaction_isolation;
```
# 当前读，行锁解决幻读
引言：MySQL InnoDB 默认的隔离级别是REPEATABLE-READ（可重复读），可重复读并不能避免幻读，如果继续提升隔离级别那就是SERIALIZABLE，这是万万不可的，因此聪明的MySQL又想出了新办法--当前读。

当前读需要对select语句加锁，而这个加锁读使用到的机制就是临建锁Next-Key Locks

在讲Next-Key Locks之前，我们需要先了解下MySQL下的各种锁。==声明：本文只讨论排他锁==
![[Pasted image 20240118162132.png]]
InnoDB 实现了标准的行锁，对行数据进行锁定，行锁包括共享锁lock in share mode和排它锁for update
- 对于共享锁而言，对当前行加共享锁，不会阻塞其他事务对同一行的读请求，但会阻塞对同一行的写请求。只有当读锁释放后，才会执行其它写操作。共享锁的脚本是lock in share mode
- 对于排它锁而言，会阻塞其他事务对同一行的读和写操作，只有当写锁释放后，才会执行其它事务的读写操作。排他锁的脚本是for update
```sql
-- 加共享行锁（S）
select * from table_name where ... lock in share mode

-- select加排它行锁（X)，对于delete、insert语句MySQL会自动给涉及数据集加排它锁X
select * from table_name where ... for update
-- 对于delete、insert语句MySQL会自动给涉及数据集加排它行锁X，
-- 对于update语句如update  goods set total_stocks = total_stocks - 1 能够自动触发行锁
update  goods set total_stocks = total_stocks - 1 ,update_time = now() where goods_id = #{value} and total_stocks - 1 >= 0
```

对于排他锁而言，InnoDB又细分了以下三种锁：
- 记录锁Record Locks
- 间隙锁Gap Locks
- 临建锁Next-Key Locks

## Record Lock记录锁

记录锁也是对表中的记录加锁，记录锁属于排他锁X，因此记录锁的加锁脚本是`FOR UPDATE`
```sql
-- 记录锁在 id=1 的记录上加上排他锁，以阻止其他事务插入，更新，删除 id=1 这一行。
SELECT * FROM `test` WHERE `id`=1 FOR UPDATE; 
```
==需要注意的是InnoDB 中的行锁的实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁==。
此外记录锁是锁住索引记录，而不是真正的数据记录。
## Gap Locks间隙锁

使用间隙锁锁住的是整个区间。
举例来说，假如emp表中只有101条记录，其empid的值分别是{1，2，...，100，101}，我们需要检索出empid>100的数据

间隙锁对记录区间施加排他锁FOR UPDATE，InnoDB不仅会对符合条件的empid=101的记录加锁，也会对empid>101的记录进行加锁，尽管这些记录并不存在。这个时候如果你插入empid等于102的数据，如果间隙锁事物还没有提交，那你就会处于等待状态，无法插入数据。

```Java
SELECT * FROM emp WHERE empid > 100 FOR UPDATE 
```

## Next-Key Lock记录锁+间隙锁

同时锁住数据+间隙锁 
==在Repeatable Read隔离级别下，Next-key Lock 算法是默认的行记录锁定算法。==
假设有如下表：id列是主键，age列是普通索引，临键锁锁定一段左开右闭的索引区间(a，b]

| id | age | name |
| ---- | ---- | ---- |
| 1 | 10 | zhangsan |
| 3 | 24 | lisi |
| 5 | 32 | wangwu |
| 7 | 45 | zhaoliu |
假如在事务A中执行如下命令，那么age列潜在的临键锁有：(-∞, 10]、(10, 24]、(24, 32]、(24, 45]、(45, +∞]
```sql
-- 根据非唯一索引列 UPDATE 某条记录 
UPDATE table SET name = Vladimir WHERE age = 24; 
-- 或根据非唯一索引列 FOR UPDATE 某条记录 
SELECT * FROM table WHERE age = 24 FOR UPDATE; 
```
不管执行了上述 SQL 中的哪一句，之后如果在事务 B 中执行以下命令，则该命令会被阻塞：
```sql
INSERT INTO table VALUES(100, 26, 'tianqi'); 
```

# 快照读，undo log实现MVCC多版本并发控制
上面我们通过对行数据加锁Next-Key-Lock，已经解决了幻读问题。

==但是精益求精MySQL的InnoDB实现了MVCC来更好地处理读写冲突，每一次修改数据，都会在 undo log 中存有快照记录，而ReadView就是undo log中的某一版本， “读” 数据时无需加锁也可以读取到数据的某一个版本的快照，从而实现"非阻塞并发读"==。这种方式的优点是可以不用加锁就可以读取到数据，缺点是读取到的数据可能不是最新的版本。在进一步了解MySQL中实现MVCC的细节之前，先回顾一下redo log 和 undo log：
- 在修改数据的时候，会向 redo log 中记录修改的页内容（为了在数据库宕机重启后恢复对数据库的操作），
- 也会向 undo log 记录数据原来的快照（用于回滚事务）。==undo log有两个作用，除了用于回滚事务，还用于实现MVCC。==

### 形成事务版本链
MySQL中，在每一行记录中除了自定义的字段，还有一些隐藏字段：
- 主键row_id这是我们的老熟人：当数据库表没定义主键时，InnoDB会以row_id为主键生成一个聚集索引作为隐藏。
- 历史事务==trx_id==：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，只读事务中的事务id值都默认为0。
- 回滚指针 roll_pointer：回滚指针指向当前记录的上一个版本（在 undo log 中），形成版本链。
用一个简单的例子来画一下MVCC中用到的undo log版本链的逻辑图：
```sql
当事务100（trx_id=100）执行了 insert into t_user values(1,'张三',21); 之后：
当事务102（trx_id=102）执行了 update t_user set name='李四' where id=1; 之后：
当事务103（trx_id=103）执行了 update t_user set name='王五' where id=1; 之后：
```
![[Pasted image 20240118185321.png]]

在上面的例子中，多个事务对 id=1 的数据修改后，这行记录除了最新的数据，在 undo log 中还有多个版本的快照。那其他事务查询时能查到最新版本的数据吗？如果不能，能读到哪个版本的快照呢？

寻找正确的事务版本就需要靠下面的ReadView了
### 寻找事务版本链
ReadView保存了活跃事务ID列表m_ids，涵盖
- 没提交的写事务m_ids
- min_trx_id：m_ids 中最小的事务id。
- max_trx_id：生成 ReadView 时，系统应该分配给下一个事务的id，公式为max(m_ids)+1
由Read View来决定当前事务能读到Undo Log中哪个版本的数据，而判断依据就是通过Read View和行记录的事务trx_id做对比的，规则如下
![[Pasted image 20240118191847.png]]
（1）当trx_id < min_trx_id，说明==历史事务trx_id==已经提交了，提交了就结束了，所以其版本记录对当前事务可见。
（2）trx_id > max_trx_id时，说明==历史事务trx_id==还未开始，其版本记录对当前事务不可见。
（3）当min_trx_id<= trx_id < max_trx_id时，判断==历史事务trx_id==是不是在当前事务ID集合（m_ids）里面
- 如果==历史事务trx_id== in (m_ids)，相当于这个历史事务trx_id还在活跃，即使执行了Commit还不算Commit，其版本记录对当前事务不可见
- 如果==历史事务trx_id== not in (m_ids)则说明这个历史事务trx_id已经Commit了，其版本记录对当前事务可见
除了m_ids之外，ReadView中还保存了creator_trx_id：生成该 ReadView 的事务的事务id。
（4）特别的，当trx_id = creator_trx_id，说明版本链中的这个版本是==历史事务trx_id==修改的，所以其版本记录对当前事务可见。

### RC和RR两种场景区分
另外，MVCC只在`READ-COMMITTED`（解决脏读）和`REPEATABLE-READ`（保证可重读）隔离级别下生效。区别是ReadView 在 RC 和 RR 两种隔离级别下生成的时机不同
- 在RC隔离级别下，每次select都会生成一个最新的ReadView；==这就是RC解决不了RR的真正原因==
- 在RR隔离级别下，事务第一次select时创建ReadView，之后一直使用。==这就是RR解决了RR的真正原因==

#### RC
来看示例流程，事务A，B几乎同时查询trx_id 为 26记录，因为是read committed (读已提交) 隔离级别，所以每次select都会生成不同的ReadView
![[Pasted image 20240118191903.png]]

我们来看事务ID分别为27和28的A、B读取trx_id 为 26 的记录，事务A进行了两次查询，而第二次是在事务B提交之后，
![[Pasted image 20240118191919.png]]

我们来两次次查询生成的ReadView的区别：
![[Pasted image 20240118191926.png]]
- 第一次事务A能查询到point值为100， 符合db_trx_id < min_trx_id规则，说明历史事务26已经提交，所以当前事务27能查询到历史事务26的版本记录（100）
- 第二次读之前事务B对数据进行了修改，并提交了事务。此时这一行数据的“历史事务ID”变成了28，符合规则 min_trx_id <= db_trx_id < maxtrxid（27<=28<29），同时db_trx_id=28不在当前系统中活跃的事务m_ids集合说明已提交，因此当前事务27可以看到历史版本的数据，也就是能查询到 point的值是150。
因此整个过程中，同一个事务A内，相同的查询条件，查询到的数据不一致，也就是出现了不可重复读的情况。
#### RR
可重复读在事务第一次select时创建ReadView，后面都是复用这个ReadView，这个和读已提交的区别所在。

事务A、B的执行情况和读已提交的流程一样，都是针对同一条记录修改前后事务提交的两次查询，但是两次查询出来的都是一样的，值都是100。
![[Pasted image 20240118191939.png]]
但是两次查询的ReadView共用一个，结果如下：
![[Pasted image 20240118191950.png]]
事务B还是修改成150，”历史事务“变成了28
![[Pasted image 20240118191553.png]]

可以看出”历史事务“还是符合规则 min_trx_id <= db_trx_id < max_trx_id（27<=28<29），

但是db_trx_id=28还在当前系统中活跃的事务m_ids集合说明没提交，因此当前事务27是看不到“历史版本db_trx_id=28”的数据，只能看到“历史版本db_trx_id=26”的数据，也就是为什么事务B提交了，但是第二次查询出来的point的值还是100。

所以通过这样的方式就实现了，就是通过复用原有ReadView的方式解决了重复读问题。

