意向锁属于表级别的锁，但意向锁并不属于真正意义上的表锁：

- **意向共享锁**（intention shared lock, IS）：事务有意向对表中的某些行加**共享锁**（S锁）
```text
-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
SELECT column FROM table ... LOCK IN SHARE MODE; 
```
- **意向排他锁**（intention exclusive lock, IX）：事务有意向对表中的某些行加**排他锁**（X锁）
```text
-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
SELECT column FROM table ... FOR UPDATE; 
```

即：意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InnoDB会代替用户先获取该数据行所在在数据表的对应意向锁（表锁）。
# 意向锁要解决的问题

我们先来看一下百度百科上对意向锁存在意义的描述：

> 如果另一个任务试图在该表级别上应用共享或排它锁（表锁），则受到由第一个任务控制的表级别意向锁的阻塞。
> 
> 第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。

设想这样一张 users 表： MySql，InnoDB，Repeatable-Read：users（id PK，name）

| id | name |
| ---- | ---- |
| 1 | ROADHOG |
| 2 | Reinhardt |
| 3 | Tracer |
| 4 | Genji |
| 5 | Hanzo |
| 6 | Mccree |

事务 A 获取了某一行的排他锁，并未提交：

```sql
SELECT * FROM users WHERE id = 6 FOR UPDATE;
```

事务 B 想要获取 users 表的表锁：

```sql
LOCK TABLES users READ;
```

因为共享锁与排他锁互斥，所以事务 B 在视图对 users 表加共享锁的时候，必须保证：

1. 当前没有其他事务持有 users 表的排他锁。
2. 当前没有其他事务持有 users 表中任意一行的排他锁 。

第一个条件很容易判断。要想检测是否满足第二个条件，事务 B 必须在确保 users表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了：

此时事务 B 检测事务 A 持有 users 表的意向排他锁，就可以得知事务 A 必然持有该表中某些数据行的排他锁，那么事务 B 对 users 表的加锁请求就会被排斥（阻塞），而无需去检测表中的每一行数据是否存在排他锁。



我们可以举个生活中的例子，再来理解下为什么需要存在意向锁。

打个比方，就像有个游乐场，很多小朋友进去玩，看门大爷如果要下班锁游乐场的门(**加表锁**)，他必须确保每个角落都要去检查一遍，确保每个小朋友都离开了(**释放行锁**)，才可以锁门。

假设锁门是件频繁发生的事情，大爷就会非常崩溃。那大爷想了一个办法，每个小朋友进入，就把自己的名字写在本子上，小朋友离开，就把自己的名字划掉，那大爷就能方便掌握有没有小朋友在游乐场里，不必每个角落都去寻找一遍。例子中的“小本子”，就是**意向锁（表锁）**，他记录的信息并不精细，他只是提醒大爷，有人在屋里。
