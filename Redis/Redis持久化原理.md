Redis是基于内存的，假设我们不做任何操作，只要Redis服务器重启或者中途故障挂掉了，那内存的数据就会没了

所以Redis提供了持久化机制给我们用，分别是RDB和AOF

# RDB（Redis DataBase）

RDB（Redis DataBase）指的就是快照，这个快照文件就称为RDB文件dump.rdb
## save

Redis 引入了按时间和按数据修改次数双重限制的快照保存机制，按照redis.conf文件里的save配置生效
```shell
save <seconds> <changes>
```
表示在seconds秒内，对redis数据执行changes次修改就会保存redis中的临时数据快照到RDB

本次案例5秒2次修改
![[Pasted image 20240120165020.png]]
第一种情况，5秒内保存2次触发RDB

![[Pasted image 20240120165008.png]]

第二种情况，两次保存间隔超过5秒，不会触发备份
![[Pasted image 20240120165123.png]]
## bgsave
save：在主程序中执行会阻塞当前redis服务器直到持久化工作完成，执行save命令期间Redis不能处理其他命令，线上禁止使用
bgsave(默认)：redis会在后台异步进行快照操作，不阻塞快照同时还可以相应客户端请求，该方式操作系统会fork一个子进程由子进程复制持久化过程

==注意是fork了子进程而不是子线程！==
![[Pasted image 20240307155750.png]]
## lastsave
还可以通过lastsave命令获取最后一次成功执行快照的时间
![[Pasted image 20240120165456.png]]
## RBD的缺点：全量备份
- 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失从当前回溯至最近一次快照期间的数据
- 内存数据的全量同步，内存中的数据被克隆了一份，大致2倍的膨胀性，如果数据量太大会导致IO严重影响服务器性能
模拟数据丢失：
![[Pasted image 20240120170247.png]]



# AOF（日志）
AOF（命令集合）则是把Redis服务器接收到的所有写操作都记录到日志appendonly.aof中(读操作不记录，这有点像mysql的binlog)，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

默认情况下，redis是没有开启AOF的，需要按照redis.conf文件里的appendonly配置生效
```shell
appendonly yes
```
AOF持久化工作流程如下，共分为五步：
![[Pasted image 20240120170940.png]]
1.Client作为命令的来源，会从多个源头源源不断的接收写命令。
2.在这些命令到达Redis Server 以后并不是直接写入AOF磁盘文件，会将其这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘IO操作。
3.AOF缓冲区（类似于RocketMQ刷盘缓冲区，也类似于秒杀架构前面挡的一层预扣减缓存）根据AOF写入策略appendsync：默认是每秒写入everysec，将这1s内的一批命令写入磁盘上的AOF文件。
4.随着写入AOF内容的增加为避免文件膨胀，会根据规则进行命令的合并(又称AOF重写)，从而起到AOF文件压缩的目的。
5.当Redis Server服务器重启的时候会读入AOF文件，重构数据。
## AOF缓冲区
AOF缓冲区（类似于RocketMQ刷盘缓冲区，也类似于秒杀架构前面挡的一层预扣减缓存），目的是为了提高性能
## 刷盘策略appendsync
![[Pasted image 20240120171203.png]]
everysec：默认策略异步，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔1秒把缓冲区中的内容写入到磁盘
ALways：同步写回，每个写命令执行完立刻同步地将日志写会磁盘，效率很低但是很可靠
no：操作系统控制的写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
## AOF文件压缩
如果这些写入磁盘的「命令集合」不做任何处理，那该「命令集合」就会一直膨胀，其实就是该文件会变得非常大
Redis当然也考虑了这一点，它会fork个子进程会对「原始」命令集合进行重写，说白了就是会压缩，压缩完了之后只要替换原始文件就好了
## AOF的优点：增量备份
- 使用AOF 持久更牢靠: 使用everysec的默认策略，写入性能仍然很棒，因此您仅仅丢失一秒钟的写入。
- AOF 日志是一个增量追加日志，因此不会出现寻道问题(RDB全量复制需要寻道)，也不会在断电时出现损坏问题。即使由于某种原因(磁盘已满或其他原因) 日志以写一半的命令结尾，redis-check-aof 工具也能够轻松修复它。
## AOF的劣势
- 相同数据集的数据而言AOF文件大于RDB文件
- 相同数据集的数据而言AOF恢复速度慢于RDB
# RDB与AOF共存
## 默认只有AOF生效

Redis配置文档解答：RDB和AOF共存时会优先加载AOF文件，因为AOF的持久化更有保障
![[Pasted image 20240120172041.png]]
## 开启混合方式设置
设置aof-use-rdb-preamble的值为yes，yes表示开启，设置为no表示禁用​

混合持久化方式产生的持久化文件一部分是RDB格式，一部分是AOF格式。