Redis是基于内存的，假设我们不做任何操作，只要Redis服务器重启或者中途故障挂掉了，那内存的数据就会没掉

所以Redis提供了持久化机制给我们用，分别是RDB和AOF

# RDB（Redis DataBase）

RDB（Redis DataBase）指的就是快照，这个快照文件就称为RDB文件dump.rdb
## save

Redis 引入了按时间和数据修改次数双重限制的快照保存机制，按照redis.conf文件里的save配置生效
```shell
save <seconds> <changes>
```
表示在seconds秒内，对redis数据执行changes次修改就会保存redis中的临时数据快照到RDB

本次案例5秒2次修改
![[Pasted image 20240120165020.png]]
第一种情况，5秒内保存2次触发RDB

![[Pasted image 20240120165008.png]]

第二种情况，两次保存间隔超过5秒，不会触发备份
![[Pasted image 20240120165123.png]]
## bgsave
save：在主程序中执行会阻塞当前redis服务器，直到持久化工作完成执行save命令期间，Redis不能处理其他命令，线上禁止使用
bgsave(默认)：redis会在后台异步进行快照操作，不阻塞快照同时还可以相应客户端请求，该方式操作系统会fork一个子进程由子进程复制持久化过程
## lastsave
还可以通过lastsave命令获取最后一次成功执行快照的时间
![[Pasted image 20240120165456.png]]
## RBD的缺点
- 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失从当前至最近一次快照期间的数据
- 内存数据的全量同步，内存中的数据被克隆了一份，大致2倍的膨胀性，如果数据量太大会导致IO严重影响服务器性能
- RDB依赖于fork的子进程，在更大的数据集中，这可能会导致服务请求的瞬间延迟。
模拟数据丢失：
![[Pasted image 20240120170247.png]]










- 而AOF（命令集合）则是把Redis服务器接收到的所有写命令都记录到日志中。Redis重跑一遍这个记录下的日志文件，就相当于还原了数据
    

那我就想问了，你上次不是说Redis是单线程吗，那比如你说的RDB，它会执行SAVE或BESAVE命令，生成文件那不是非常耗时的吗，那如果只有一个线程处理，那其他的请求不就得等了？

# AOF（日志）
以日志的形式来记录每个写操作以日志appendonly.aof的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但是不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

默认情况下，redis是没有开启AOF的，需要按照redis.conf文件里的appendonly配置生效
```shell
appendonly yes
```
AOF持久化工作流程如下，共分为五步：
![[Pasted image 20240120170940.png]]
1.Client作为命令的来源，会有多个源头以及源源不断的请求命令。
2.在这些命令到达Redis Server 以后并不是直接写入AOF文件，会将其这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘IO操作。
3.AOF缓冲区根据**配置信息appendsync：AOP的三种持久化策略**将命令写入磁盘上的AOF文件。
4.随着写入AOF内容的增加为避免文件膨胀，会根据规则进行命令的合并(**又称AOF重写**)，从而起到AOF文件压缩的目的。
5.当Redis Server服务器重启的时候会队AOF文件载入数据。
## AOF缓冲区三种写回策略
![[Pasted image 20240120171203.png]]
**everysec**：默认策略，每秒写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔1秒把缓冲区中的内容写入到磁盘
**ALways**：同步写回，每个写命令执行完立刻同步地将日志写会磁盘
**no**：操作系统控制的写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
## AOF文件压缩
如果这些写入磁盘的「命令集合」不做任何处理，那该「命令集合」就会一直膨胀，其实就是该文件会变得非常大
Redis当然也考虑了这一点，它会fork个子进程会对「原始」命令集合进行重写，说白了就是会压缩，压缩完了之后只要替换原始文件就好了
## AOF的优点
- 使用AOF Redis 更加持久: 使用everysec的默认策略，写入性能仍然很棒，因此您只能丢失一秒钟的写入。
- AOF 日志是一个仅附加日志，因此不会出现寻道问题，也不会在断电时出现损坏问题。即使由于某种原因(磁盘已满或其他原因) 日志以写一半的命令结尾，redis-check-aof 工具也能够轻松修复它。
## AOF的劣势
- 相同数据集的数据而言AOF文件要远大于RDB文件，恢复速度慢于RDB
- AOF运行效率要慢于RDB，每秒同步策略效率较好，不同步效率和RDB相同
# RDB与AOF共存
## 默认只有AOF生效

Redis配置文档解答：RDB和AOF共存时会优先加载AOF文件，因为AOF的持久化更有保障
![[Pasted image 20240120172041.png]]
## 开启混合方式设置
设置aof-use-rdb-preamble的值为yes，yes表示开启，设置为no表示禁用​

混合持久化方式产生的持久化文件一部分是RDB格式，一部分是AOF格式。