生产中redis往往会做集群，在redis集群状态下，我们的分布式锁存在以下的问题：
1. 并发线程A从master获取到锁，master会默认根据rdb或者aof向各个slave节点同步并发线程的锁信息
2. 在master将锁同步到slave之前，master宕掉了。
3. slave节点被晋级为master节点，
4. 但由于步骤2，此时的新晋master并不知道锁已经被并发线程A拿到了，因此并发线程B又重复获取了并发线程A持有的锁，又会出现并发超卖问题

解决集群下锁失效，参照redis官方网站针对redlock文档：https://redis.io/topics/distlock

在算法的分布式版本中，我们假设有N个Redis服务器，这些节点是完全独立的。将N设置为5是一个合理的值，因此需要在不同的计算机或虚拟机上运行5个Redis主服务器，确保它们以独立的方式发生故障。
![[Pasted image 20240123185647.png]]
为了获取锁，应用程序并发线程执行以下操作：
1. 并发线程以毫秒为单位获取当前时间的时间戳，作为起始时间。
2. 并发线程尝试在所有N个实例中顺序使用相同的键名、相同的随机值来获取锁定。每个实例尝试获取锁都需要时间，客户端应该设置一个远小于总锁定时间的超时时间。例如，如果自动释放时间为30秒，则尝试获取锁的超时时间不能超过30秒。这样可以防止并发线程长时间与故障状态的Redis节点进行通信：如果某个实例不可用，尽快尝试与下一个实例进行通信。
3. 计算获取锁所花费的时间，用当前时间（步骤3的当前时间），减去在步骤1中获得的起始时间。当且仅当客户端能够在半数以上实例（至少3个）中获取锁时，并且获取锁所花费的总时间小于锁有效时间，则认为已获取锁。
4. 如果获取了锁，计算剩余锁定时间，用锁的有效时间，减去步骤3中计算出的获取锁所花费的时间。
5. 如果客户端由于某种原因（无法锁定N / 2 + 1个实例或有效时间为负）而未能获得该锁，它将尝试解锁所有实例（即使没有锁定成功的实例）。