jvm中的synchronized，Lock，这些都是本地锁，本地锁只能锁住当前服务，示例如下：
```java
//单实例StockService
@Service  
public class StockService {  

	//由于StockService是单实例，因此Stock也是单实例
    private Stock stock = new Stock();  
  
    private ReentrantLock lock = new ReentrantLock();  
  
    public void deduct(){  
//        lock.lock();  
        try {  
            stock.setStock(stock.getStock() - 1);  
            System.out.println("库存余量：" + stock.getStock());  
        } finally {  
//            lock.unlock();  
        }  
    }  
}

@Data  
public class Stock {  
  
    private Integer stock = 5000;  
}
```
通过jmeter模拟100线程x50人=5000个并发，如果说上述服务只有一份，那么Lock就可以锁住

但是，如果上述服务我们通过idea复制了多份，并且通过nginx负载均衡，那么jvm的lock就失效了
nginx.conf差不多的配置如下：
```shell
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    #include /etc/nginx/conf.d/*.conf;
	
	upstream distributed {
		server 172.16.116.1:8000;
		server 172.16.116.1:8100;
		server 172.16.116.1:8200;
	}
	
	server {
		listen       80;
        server_name  172.16.116.100;
		location / {
			proxy_pass http://distributed;
		}
	}
	
}
```

==仔细观察为什么jvm本地锁失效了，因为jvm本地锁只能锁住当前服务（module）内的资源Stock，一旦当前服务副本被复制了多份，则Stock就无法当作所有服务的全局共享资源了，而是只在各自的服务内部共享==

所以，分布式锁的实现思路就是，将共享资源移到程序外部，找一个全局共享的存储结构来存放我们的共享资源即可
![[Pasted image 20240120220750.png]]
而这个全局共享的存储结构就可以利用MySQL，Redis，zookeeper来做


