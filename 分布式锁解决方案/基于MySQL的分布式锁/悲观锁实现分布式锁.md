# select悲观锁-for update

在数据库中 for update 关键字用于对select语句家悲观锁，
我们在 Mapper 中添加 for update 即可对数据加锁，实现代码如下：

```xml
<!-- UserMapper.xml -->
<select id="selectByIdForUpdate" resultType="User">
    SELECT * FROM user WHERE id = #{id} FOR UPDATE
</select>
```

在 Service 中调用 Mapper 方法，即可获取到加锁的数据：
```Java
@Transactional
public void updateWithPessimisticLock(int id, String name) {
    User user = userMapper.selectByIdForUpdate(id);
    if (user != null) {
        user.setName(name);
        userMapper.update(user);
    } else {
        throw new RuntimeException("数据不存在");
    }
}
```

# update悲观锁
对于update语句来说，使用类似于如下的复合操作update goods set total_stocks = total_stocks - 1 可以自动触发行锁
```java
@Override  
public void onMessage(MessageExt message) {  
    String msg = new String(message.getBody());  
    // userId + "-" + goodsId  
    Integer userId = Integer.parseInt(msg.split("-")[0]);  
    Integer goodsId = Integer.parseInt(msg.split("-")[1]);  
    goodsService.realSeckill(userId, goodsId);  
}
```
service：
```java
@Override  
@Transactional(rollbackFor = Exception.class)  
public void realSeckill(Integer userId, Integer goodsId) {  
    // update goods set total_stocks = total_stocks - 1 where goods_id = goodsId and total_stocks - 1 >= 0;  
    // 通过mysql来控制锁  
    int i = goodsMapper.updateStock(goodsId);  
    if (i > 0) { //同时创建当前订单
        Order order = new Order();  
        order.setGoodsid(goodsId);  
        order.setUserid(userId);  
        order.setCreatetime(new Date());  
        orderMapper.insert(order);  
    }  
}
```
xml：
```java
<update id="updateStock">  
  update  goods set total_stocks = total_stocks - 1 ,update_time = now() 
	  where goods_id = #{value} and total_stocks - 1 >= 0  
</update>
```
但mysql不适合并发较大场景  ，性能感人



