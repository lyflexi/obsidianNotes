这个问题对面试者要求较高，它不仅要了解实现方法，还要对原理有所掌握。所以问题回答起来，分为很多层次。
# 实现原理
redis的分布式锁，可以基于setnx指令实现，需要考虑以下细节：
- 防死锁，锁过期时间
- 防误删1，加uuid
- 防误删2，加lua脚本
- 可重入实现，使用hash锁结构
- 锁续期
zk的分布式锁，其ZNode天然具有锁的属性，需要考虑以下细节：
- 防死锁，必须使用临时节点
- 使用自旋锁初步实现
- 优化1，序列化节点实现阻塞锁
- 优化2，序列化节点阻塞锁+监听watcher
- 可重入实现
- 综上所述，是基于临时节点的有序性和节点的监听机制完成的
这种回答方式，直接把自己给绕进去了，因为这涉及到非常多的细节。别人只是问区别，为什么把自己往源码级别绕呢？ 相信自己实力过硬
# 现成框架
建议回答：
- Redis，使用redisson封装的RedLock
- Zk，使用curator封装的InterProcessMutex
# 服务端性能redis > Zookeeper

Zk基于Zab协议，需要一半的节点ACK，才算写入成功，吞吐量较低。如果频繁加锁、释放锁，服务端集群压力会很大。

Redis基于内存，只写Master就算成功，吞吐量高，Redis服务器压力小。

# 客户端性能Zookeeper > redis

Zk由于有通知机制，获取锁的过程，添加一个监听器就可以了。避免了轮询，性能消耗较小。

Redis并没有通知机制，它只能使用类似CAS的轮询方式去争抢锁，较多自旋空转，会对客户端造成压力。

# 可靠性CAP理论（服务端性能）
Consistency：一致性，数据在多个副本中能保持一致的状态。意味着每次读取都会获取最新的写入数据或异常
Availability：可用性，整个系统在任何时刻都能提供可用的服务。意味着可以对每个请求得到非异常的响应，而不保证获取最新的写入数据
PartitionTolerance：分区容错性。服务器需要有容错性，因此P肯定存在
因此上面的三种特性只有下述两种组合方式：
- CP：满足一致性和分区容错性，通常性能不是特别高。比如[zookeeper分布式锁的集群版]是CP架构，Zookeeper就是为协调而生的，Zk基于严格的Zab协议控制数据的一致性，需要一半的节点ACK，才算写入成功，锁模型健壮但是吞吐量较低。如果频繁加锁、释放锁，服务端集群压力会很大。
- AP：满足可用性和分区容错性，对一致性要求低一些，大多数建站首选。比如[redis分布式锁集群版]是AP架构，Redis基于内存，只写Master就算成功，吞吐量高，Redis服务器压力小。即使使用了Redlock，也无法保证100%的健壮性，可靠性上稍逊一筹


