为了让我们的 MiniSpring 更加专业一点，也更像 Spring 一点，我们将实现 3 个功能点。
1. 进一步增强扩展性，新增 4 个接口。
	1. ListableBeanFactory
	2. ConfigurableBeanFactory
	3. ConfigurableListableBeanFactory
	4. EnvironmentCapable
2. 实现 DefaultListableBeanFactory，该类就是 Spring IoC 的引擎。
3. 改造 ApplicationContext。
# 新增4个工厂接口
为了扩展性，进一步提出几个interface：  
## ListableBeanFactory接口
ListableBeanFactory接口扩展beanfactory，提供一些bean集合的方法。  
```java
public interface ListableBeanFactory extends BeanFactory {  
    boolean containsBeanDefinition(String beanName);  
    int getBeanDefinitionCount();  
    String[] getBeanDefinitionNames();  
    String[] getBeanNamesForType(Class<?> type);  
    <T> Map<String, T> getBeansOfType(Class<T> type) throws BeansException;  
}
``` 
## ConfigurableBeanFactory接口
ConfigurableBeanFactory接口扩展BeanFactory,SingletonBeanRegistry，提供BeanPostProcessor和dependent方法：  
- addBeanPostProcessor：支持 Bean 处理器
- getDependentBeans：维护 Bean 之间的依赖关系
```java
public interface ConfigurableBeanFactory extends BeanFactory,SingletonBeanRegistry {  
    String SCOPE_SINGLETON = "singleton";  
    String SCOPE_PROTOTYPE = "prototype";  
    void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);  
    int getBeanPostProcessorCount();  
    void registerDependentBean(String beanName, String dependentBeanName);  
    String[] getDependentBeans(String beanName);  
    String[] getDependenciesForBean(String beanName);  
}
```
## AutowireCapableBeanFactory接口
AutowireCapableBeanFactory 就是在通用的 BeanFactory 的基础上添加了 Autowired 注解特性
AutowireCapableBeanFactory接口提供通过beanpostprocessor实现Autowired方法：  
```java
public interface AutowireCapableBeanFactory  extends BeanFactory{  
    int AUTOWIRE_NO = 0;  
    int AUTOWIRE_BY_NAME = 1;  
    int AUTOWIRE_BY_TYPE = 2;  
    Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)  
          throws BeansException;  
    Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)  
          throws BeansException;  
}
```
## ConfigurableListableBeanFactory接口，集成上面的三个interface
再用一个interface ConfigurableListableBeanFactory把上面的三个interface集成在一起。  
```java
public interface ConfigurableListableBeanFactory  
    extends ListableBeanFactory, AutowireCapableBeanFactory, ConfigurableBeanFactory {  
}
```
  
这是设计的原则之一：接口隔离。 每个接口提供单一功能，可以组合选择实现那些接口。  

由于 ConfigurableListableBeanFactory 继承了 AutowireCapableBeanFactory，所以我们需要调整之前定义的 AutowireCapableBeanFactory，由 class 改为 interface。
```java
public interface AutowireCapableBeanFactory  extends BeanFactory{
    int AUTOWIRE_NO = 0;
    int AUTOWIRE_BY_NAME = 1;
    int AUTOWIRE_BY_TYPE = 2;
    Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, 
String beanName) throws BeansException;
    Object applyBeanPostProcessorsAfterInitialization(Object existingBean, 
String beanName) throws BeansException;
}
```
新增抽象类 AbstractAutowireCapableBeanFactory 替代原有的实现类。
```java
public abstract class AbstractAutowireCapableBeanFactory 
                        extends AbstractBeanFactory implements 
AutowireCapableBeanFactory{
    private final List<BeanPostProcessor> beanPostProcessors = new 
ArrayList<BeanPostProcessor>();
    
    public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
        this.beanPostProcessors.remove(beanPostProcessor);
        this.beanPostProcessors.add(beanPostProcessor);
    }
    public int getBeanPostProcessorCount() {
        return this.beanPostProcessors.size();
    }
    public List<BeanPostProcessor> getBeanPostProcessors() {
        return this.beanPostProcessors;
    }
    public Object applyBeanPostProcessorsBeforeInitialization(Object 
existingBean, String beanName)
            throws BeansException {
        Object result = existingBean;
        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
            beanProcessor.setBeanFactory(this);
            result = beanProcessor.postProcessBeforeInitialization(result, 
beanName);
            if (result == null) {
                return result;
            }
        }
        return result;
    }
    public Object applyBeanPostProcessorsAfterInitialization(Object 
existingBean, String beanName)
            throws BeansException {
        Object result = existingBean;
        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
            result = beanProcessor.postProcessAfterInitialization(result, 
beanName);
            if (result == null) {
                return result;
            }
        }
        return result;
    }   
}
```
# 环境Environment
除了扩充 BeanFactory 体系，我们还打算给容器增加一些环境因素，使一些容器整体所需要的属性有个地方存储访问。

在 core 目录下新建 env 目录，增加 三个接口类
- PropertyResolver.java、
- EnvironmentCapable.java、
- Environment.java 。
EnvironmentCapable 主要用于获取 Environment 实例，Environment 则继承 PropertyResoulver 接口，用于获取属性。所有的 ApplicationContext 都实现了 Environment 接口。

Environment.java 接口
```java
public interface Environment extends PropertyResolver {
    String[] getActiveProfiles();
    String[] getDefaultProfiles();
    boolean acceptsProfiles(String... profiles);
}
```
EnvironmentCapable.java 接口
```java
public interface EnvironmentCapable {
    Environment getEnvironment();
}
```
PropertyResolver.java 接口
```java
public interface PropertyResolver {
    boolean containsProperty(String key);
    String getProperty(String key);
    String getProperty(String key, String defaultValue);
    <T> T getProperty(String key, Class<T> targetType);
    <T> T getProperty(String key, Class<T> targetType, T defaultValue);
    <T> Class<T> getPropertyAsClass(String key, Class<T> targetType);
    String getRequiredProperty(String key) throws IllegalStateException;
    <T> T getRequiredProperty(String key, Class<T> targetType) throws 
IllegalStateException;
    String resolvePlaceholders(String text);
    String resolveRequiredPlaceholders(String text) throws 
IllegalArgumentException;
}
```
# IoC的引擎发动机,DefaultListableBeanFactory
接下来我们看看 IoC 引擎——DefaultListableBeanFactory 的实现，这个类现在成了IoC的引擎。  
DefaultListableBeanFactory它继承了 AbstractAutowireCapableBeanFactory 并实现了 ConfigurableListableBeanFactory 接口。
![[Pasted image 20240110193118.png]]
```java
public class DefaultListableBeanFactory extends 
AbstractAutowireCapableBeanFactory 
                    implements ConfigurableListableBeanFactory{
    public int getBeanDefinitionCount() {
        return this.beanDefinitionMap.size();
    }
    public String[] getBeanDefinitionNames() {
        return (String[]) this.beanDefinitionNames.toArray();
    }
    public String[] getBeanNamesForType(Class<?> type) {
        List<String> result = new ArrayList<>();
        for (String beanName : this.beanDefinitionNames) {
            boolean matchFound = false;
            BeanDefinition mbd = this.getBeanDefinition(beanName);
            Class<?> classToMatch = mbd.getClass();
            if (type.isAssignableFrom(classToMatch)) {
                matchFound = true;
            }
            else {
                matchFound = false;
            }
            if (matchFound) {
                result.add(beanName);
            }
        }
        return (String[]) result.toArray();
    }
    @SuppressWarnings("unchecked")
    @Override
    public <T> Map<String, T> getBeansOfType(Class<T> type) throws BeansException
{
        String[] beanNames = getBeanNamesForType(type);
        Map<String, T> result = new LinkedHashMap<>(beanNames.length);
        for (String beanName : beanNames) {
            Object beanInstance = getBean(beanName);
            result.put(beanName, (T) beanInstance);
        }
        return result;
    }
}

```
可以看出，我们的 MiniSpring 跟 Spring 框架设计得几乎是一模一样。当然，这是我们有意为之，我们手写 MiniSpring 就是为了深入理解 Spring。

当 ClassPathXmlApplicationContext 这个 Spring 核心启动类运行时，注入了 DefaultListableBeanFactory，为整个 Spring 框架做了默认实现，这样就完成了框架内部的逻辑闭环。  
```java
public class ClassPathXmlApplicationContext implements ApplicationContext{  
    DefaultListableBeanFactory beanFactory;  
    private final List<BeanFactoryPostProcessor> beanFactoryPostProcessors =  
          new ArrayList<BeanFactoryPostProcessor>();  
}
```

# 事件Event
接着我们来完善事件的发布与监听，包括 ApplicationEvent、ApplicationListener、ApplicationEventPublisher 以及 ContextRefreshEvent，事件一经发布就能让监听者监听到。
ApplicationEvent
```java
public class ApplicationEvent extends EventObject {
    private static final long serialVersionUID = 1L;
    protected String msg = null;
    public ApplicationEvent(Object arg0) {
        super(arg0);
        this.msg = arg0.toString();
    }
}
```
ApplicationListener
```java
public class ApplicationListener implements EventListener {
    void onApplicationEvent(ApplicationEvent event) {
        System.out.println(event.toString());
    }
}
```
ContextRefreshEvent
```java
public class ContextRefreshEvent extends ApplicationEvent{
    private static final long serialVersionUID = 1L;
    public ContextRefreshEvent(Object arg0) {
        super(arg0);
    }
    
    public String toString() {
        return this.msg;
    }
}
```
ApplicationEventPublisher
```java
public interface ApplicationEventPublisher {
    void publishEvent(ApplicationEvent event);
    void addApplicationListener(ApplicationListener listener);
}
```

可以看出，框架的 EventPublisher，本质是对 JDK 事件类的封装。接口已经定义好了，接下来我们实现一个最简单的事件发布者 SimpleApplicationEventPublisher。
```java
public class SimpleApplicationEventPublisher implements 
ApplicationEventPublisher{
    List<ApplicationListener> listeners = new ArrayList<>();
    @Override
    public void publishEvent(ApplicationEvent event) {
        for (ApplicationListener listener : listeners) {
	        //执行listener的回调方法onApplicationEvent
            listener.onApplicationEvent(event);         
        }
    }
    @Override
    public void addApplicationListener(ApplicationListener listener) {
        this.listeners.add(listener);
    }
}
```

这个事件发布监听机制就可以为后面 ApplicationContext 的使用服务了。


# 完整的 ApplicationContext
最后，我们来完善 ApplicationContext，并把它作为公共接口，所有的上下文都实现自ApplicationContext，支持上下文环境和事件发布。
我们计划做 4 件事。
1. 抽取 ApplicationContext 接口，实现更多有关上下文的内容。
2. 支持事件的发布与监听。
3. 新增 AbstractApplicationContext，规范刷新上下文 refresh 方法的步骤规范，且将每一步骤进行抽象，提供默认实现类，同时支持自定义。
4. 完成刷新之后发布事件。
## 定义ApplicationContext接口
首先我们来增加 ApplicationContext 接口的内容，丰富它的功能。
```java
public interface ApplicationContext 
        extends EnvironmentCapable, ListableBeanFactory, ConfigurableBeanFactory, ApplicationEventPublisher{
    String getApplicationName();
    long getStartupDate();
    ConfigurableListableBeanFactory getBeanFactory() throws 
IllegalStateException;
    void setEnvironment(Environment environment);
    Environment getEnvironment();
    void addBeanFactoryPostProcessor(BeanFactoryPostProcessor postProcessor);
    void refresh() throws BeansException, IllegalStateException;
    void close();
    boolean isActive();
}
```
还是按照以前的模式，先定义接口，然后用一个抽象类搭建骨架，最后提供一个具体实现类进行默认实现。==Spring 的这个 interface-abstract-class 模式是值得我们学习的，它极大地增强了框架的扩展性==。
### 定义abstract AbstractApplicationContext#refresh
我们重点看看 AbstractApplicationContext 的实现。虽然现在我们只做到了从 XML 里读取配置，用来获取应用的上下文信息，但实际 Spring 框架里不只支持这一种方式。但无论哪种方式，究其本质都是对应用上下文的处理，所以我们来抽象 ApplicationContext 的公共部分。
```java
public abstract class AbstractApplicationContext implements ApplicationContext{
    private Environment environment;
    private final List<BeanFactoryPostProcessor> beanFactoryPostProcessors = new 
ArrayList<>();
    private long startupDate;
    private final AtomicBoolean active = new AtomicBoolean();
    private final AtomicBoolean closed = new AtomicBoolean();
    private ApplicationEventPublisher applicationEventPublisher;
    @Override
    public Object getBean(String beanName) throws BeansException {
        return getBeanFactory().getBean(beanName);
    }
    public List<BeanFactoryPostProcessor> getBeanFactoryPostProcessors() {
        return this.beanFactoryPostProcessors;
    }
    public void refresh() throws BeansException, IllegalStateException {
        postProcessBeanFactory(getBeanFactory());
        registerBeanPostProcessors(getBeanFactory());
        initApplicationEventPublisher();
        onRefresh();
        registerListeners();
        finishRefresh();
    }
    abstract void registerListeners();
    abstract void initApplicationEventPublisher();
    abstract void postProcessBeanFactory(ConfigurableListableBeanFactory 
beanFactory);
    abstract void registerBeanPostProcessors(ConfigurableListableBeanFactory 
beanFactory);
    abstract void onRefresh();
    abstract void finishRefresh();
    @Override
    public String getApplicationName() {
        return "";
    }
    @Override
    public long getStartupDate() {
        return this.startupDate;
    }
    @Override
    public abstract ConfigurableListableBeanFactory getBeanFactory() throws 
IllegalStateException;
    @Override
    public void addBeanFactoryPostProcessor(BeanFactoryPostProcessor 
postProcessor) {
        this.beanFactoryPostProcessors.add(postProcessor);
    }
    @Override
    public void close() {
    }
    @Override
    public boolean isActive(){
        return true;
    }
    //省略包装beanfactory的方法
}
```

上面这段代码的核心是 refresh() 方法的定义，而这个方法又由下面这几个步骤组成。
```java
    abstract void registerListeners();
    abstract void initApplicationEventPublisher();
    abstract void postProcessBeanFactory(ConfigurableListableBeanFactory 
beanFactory);
    abstract void registerBeanPostProcessors(ConfigurableListableBeanFactory 
beanFactory);
    abstract void onRefresh();
    abstract void finishRefresh();
```
看名字就比较容易理解：首先是注册监听者，接下来初始化事件发布者，随后处理 Bean 以及对 Bean 的状态进行一些操作，最后是将初始化完毕的 Bean 进行应用上下文刷新以及完成刷新后进行自定义操作。因为这些方法都有 abstract 修饰，允许把这些步骤交给用户自定义处理，因此极大地增强了扩展性。
#### 改造ClassPathXmlApplicationContext
我们现在已经拥有了一个 ClassPathXmlApplicationContext，我们以这个类为例，看看如何实现上面的几个步骤。ClassPathXmlApplicationContext 代码改造如下：
```java
public class ClassPathXmlApplicationContext extends AbstractApplicationContext{
	//内部绑定了IOC的发动机DefaultListableBeanFactory beanFactory;
    DefaultListableBeanFactory beanFactory;
    private final List<BeanFactoryPostProcessor> beanFactoryPostProcessors = new 
ArrayList<>();
    public ClassPathXmlApplicationContext(String fileName) {
        this(fileName, true);
    }
    public ClassPathXmlApplicationContext(String fileName, boolean isRefresh) {
        Resource resource = new ClassPathXmlResource(fileName);
        DefaultListableBeanFactory beanFactory = new 
DefaultListableBeanFactory();
        XmlBeanDefinitionReader reader = new 
XmlBeanDefinitionReader(beanFactory);
        reader.loadBeanDefinitions(resource);
        this.beanFactory = beanFactory;
        if (isRefresh) {
            try {
                refresh();
            }
       }
    }
    @Override
    void registerListeners() {
        ApplicationListener listener = new ApplicationListener();
        this.getApplicationEventPublisher().addApplicationListener(listener);
    }
    @Override
    void initApplicationEventPublisher() {
        ApplicationEventPublisher aep = new SimpleApplicationEventPublisher();
        this.setApplicationEventPublisher(aep);
    }
    @Override
    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    }
    @Override
    public void publishEvent(ApplicationEvent event) {
        this.getApplicationEventPublisher().publishEvent(event);
    }
    @Override
    public void addApplicationListener(ApplicationListener listener) {
        this.getApplicationEventPublisher().addApplicationListener(listener);
    }
    public void addBeanFactoryPostProcessor(BeanFactoryPostProcessor 
postProcessor) {
        this.beanFactoryPostProcessors.add(postProcessor);
    }
    @Override
    void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) 
{
        this.beanFactory.addBeanPostProcessor(new 
AutowiredAnnotationBeanPostProcessor());
    }
    @Override
    void onRefresh() {
        this.beanFactory.refresh();
    }
    @Override
    public ConfigurableListableBeanFactory getBeanFactory() throws 
IllegalStateException {
        return this.beanFactory;
    }
    @Override
    void finishRefresh() {
        publishEvent(new ContextRefreshEvent("Context Refreshed..."));
    }
}
```
上述代码分别实现了几个抽象方法，就很高效地把 ClassPathXmlApplicationContext 类融入到了 ApplicationContext 框架里了。Spring 的这个设计模式值得我们学习，采用抽象类的方式来解耦，为用户提供了极大的扩展性的便利，这也是 Spring 框架强大的原因之一。Spring 能集成 MyBatis、MySQL、Redis 等框架，少不了设计模式在背后支持。

至此，我们的 IoC 容器就完成了，它很简单，但是这个容器麻雀虽小五脏俱全，关键是为我们深入理解 Spring 框架提供了很好的解剖样本。
![[Pasted image 20240110194203.png]]小结：
经过这节课的学习，我们初步构造了一个完整的 IoC 容器，目前它的功能包括 4 项。
1. 识别配置文件中的 Bean 定义，创建 Bean，并放入容器中进行管理。
2. 支持配置方式或者注解方式进行 Bean 的依赖注入。
3. 构建了 BeanFactory 体系。
4. 容器应用上下文和事件发布。
对照 Spring 框架，上述几点就是 Spring IoC 的核心。通过这个容器，我们构建应用程序的时候，将业务逻辑封装在 Bean 中，把对 Bean 的创建管理交给框架，即所谓的“控制反转”，应用程序与框架程序互动，共同运行完整程序。

实现这些概念和特性的手段和具体代码，我们都有意模仿了 Spring，它们的结构和名字都是一样的，所以你回头阅读 Spring 框架本身代码的时候，会觉得很熟悉，学习曲线平滑。我们沿着大师的脚步往前走，不断参照大师的作品，吸收大师的养分培育自己，让我们的 MiniSpring 一步步成长为一棵大树。