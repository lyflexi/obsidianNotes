我们先是抽象出了 Bean 的定义，用一个 XML 进行配置，然后通过一个简单的 Factory 读取配置，创建 bean 的实例。这个极简容器只有一两个类，但是实现了 bean 的读取，这是原始的种子。

然后再扩展 Bean，给 Bean 增加一些属性，如 constructor、property 和 init-method。此时的属性值还是普通数据类型，没有对象。然后我们将属性值扩展到引用另一个 Bean，实现依赖注入，同时解决了循环依赖问题。

之后通过 BeanPostProcessor 机制让容器支持注解，定义AutowiredAnnotationBeanPostProcessor实现BeanPostProcessor，重写postProcessBeforeInitialization方法解析注解
```java
package org.lyflexi.framework.beans.factory.annotation;  
  
import java.lang.reflect.Field;  
  
import org.lyflexi.framework.beans.BeansException;  
import org.lyflexi.framework.beans.factory.BeanFactory;  
import org.lyflexi.framework.beans.factory.BeanFactoryAware;  
import org.lyflexi.framework.beans.factory.config.BeanPostProcessor;  
  
public class AutowiredAnnotationBeanPostProcessor implements BeanPostProcessor,BeanFactoryAware {  
    private BeanFactory beanFactory;  
      
    @Override  
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {  
       Object result = bean;  
         
       Class<?> clazz = bean.getClass();  
       Field[] fields = clazz.getDeclaredFields();  
       if(fields!=null){  
          for(Field field : fields){  
             boolean isAutowired = field.isAnnotationPresent(Autowired.class);  
             if(isAutowired){  
                String fieldName = field.getName();  
                Object autowiredObj = this.getBeanFactory().getBean(fieldName);  
                try {  
                   field.setAccessible(true);  
                   field.set(bean, autowiredObj);  
                   System.out.println("autowire " + fieldName + " for bean " + beanName);  
                   System.out.println("autowire " + fieldName + " for bean " + beanName + " : " + autowiredObj + " class : "+autowiredObj.getClass());  
                } catch (IllegalArgumentException e) {  
                   e.printStackTrace();  
                } catch (IllegalAccessException e) {  
                   e.printStackTrace();  
                }  
  
             }  
          }  
       }  
         
       return result;  
    }  
  
    @Override  
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {  
       // TODO Auto-generated method stub  
       return bean;  
    }  
  
    public BeanFactory getBeanFactory() {  
       return beanFactory;  
    }  
  
    public void setBeanFactory(BeanFactory beanFactory) {  
       this.beanFactory = beanFactory;  
    }  
  
  
}
```
最后我们将 BeanFactory 扩展成一个体系，并增加应用上下文和容器事件侦听机制，完成一个完整的 IoC 容器。
![[Pasted image 20240110200132.png]]
我们实现了 Autowired 注解，在现有框架中能否支持多个注解？

如果这些注解是不同作用的，那么在现有架构中是可以支持多个注解并存的。比如要给某个属性上添加一个 @Require 注解，表示这个属性不能为空，我们来看下实现的思路。

MiniSpring 中，对注解的解释是通过 BeanPostProcessor 来完成的。

我们增加一个 RequireAnnotationBeanPostProcessor 类，在它的 postProcessAfterInitialization() 方法中解释这个注解，判断目标属性是不是为空，如果为空则抛出 BeanException。
```java
postProcessAfterInitialization(){

}
```
然后改写 ClassPathXmlApplicationContext 类中的 registerBeanPostProcessors() 方法，将这个新定义的 beanpostprocessor 注册进去。

```java
beanFactory.addBeanPostProcessor(new RequireAnnotationBeanPostProcessor());
```
这样，在 getBean() 方法中就会在 init-method 被调用后用到这个 RequireAnnotationBeanPostProcessor。